; Couplement Forth {{{1

; This file is part of
; Couplement Forth
; (http://programandala.net/en.program.couplement_forth.html),
; by Marcos Cruz (programandala.net), 2015, 2016, 2020.

; Couplement Forth is an experimental subroutine-threaded Forth
; system under development for the ZX Spectrum.

  macro version
    ; After Semantic Versioning (http://semver.org)
    db "0.2.0-dev.13.0+202005281624"
  endm

; --------------------------------------------------------------
; License

; Copyright (C) 2015,2016,2020 Marcos Cruz (programandala.net)

; You may do whatever you want with this work, so long as you
; retain all copyright notices, all credit notices, and this
; license in all files of all redistributed copies and derived
; works. There is no warranty.

; --------------------------------------------------------------
; Credits

; Couplement Forth was forked from ForthCoupe
; (http://programandala.net/en.program.forthcoupe.html), an
; abandoned Forth for the SAM Coup√©, based on John A. Avis'
; SamForth (http://programandala.net/en.program.samforth.html).

; ==============================================================
; Symbols {{{1

; --------------------------------------------------------------
; Forth

precedence_bit:       equ 6
immediate:            equ 1 << precedence_bit ; bit mask
compile_only_bit:     equ 7
compile_only:         equ 1 << compile_only_bit ; bit mask
interpret_only_bit:   equ 0
interpret_only:       equ 1 << interpret_only_bit ; bit mask

colon_structure_id:   equ 0x01
do_structure_id:      equ 0x02
begin_structure_id:   equ 0x03
if_structure_id:      equ 0x04
builds_structure_id:  equ 0x09

; --------------------------------------------------------------
; ZX Spectrum

  include zx_spectrum_system_variables.z80s
  include zx_spectrum_rom_routines.z80s
  include zx_spectrum_char_codes.z80s

; --------------------------------------------------------------
; Other

false:  equ 0x0000
true:   equ 0xffff
; XXX FIXME -- the legacy code uses 1 as true flag

; ==============================================================
; Assembling options {{{1

; --------------------------------------------------------------
; Data stack method {{{2

; Couplement Forth can use different methods to manage its data
; stack. Every method has a constant identifier:

sp_dsm: equ %0001 ; use SP with the contents of `dsp`
iy_dsm: equ %0010 ; use IY with the contents of `dsp`
ix_dsm: equ %0100 ; use IX to hold the stack pointer permanently
hl_dsm: equ %1000 ; use HL with the contents of `dsp`

; The data stack method can be selected here, using one of the
; above identifiers:

data_stack_method:  equ sp_dsm
any_dsm:            equ data_stack_method ; XXX TODO -- simpler

; --------------------------------------------------------------
; Execution speed {{{2

; Couplement Forth can be compiled in two modes: normal
; (default) and safe. In safe mode, the data stack limits are.

safe_mode: equ false

; Some stack operations can be faster by manipulating the stack
; directly (thus without any error checking) instead of calling
; the push/pop routines.  This configuration is independent from
; the speed mode above.

faster_stack_operations: equ true

; --------------------------------------------------------------
; Size {{{2

; When size optimization is on, relative jumps are used when
; possible, and some inline code is replaced with calls.  Some
; bytes will be saved, but the code will be a bit slower.

; XXX TODO
size_optimization: equ false

; --------------------------------------------------------------
; Screen {{{2

; XXX TODO
whole_screen: equ false ; does the input line uses the whole screen?

; ==============================================================
; Start {{{1

start: equ 25000

  org start

  jp cold_start
  jp warm_start

; ==============================================================
; Interface to BASIC {{{1

; XXX TODO

filename_length equ 10

drive:
  db 1
filename.0: ; main filename buffer
  ds filename_length
filename.1: ; secondary filename buffer
  ds filename_length
file_address:
  dw 0
file_length:
  dw 0

include fn_dpeek.z80s
include fn_peeks.z80s

basic_line_of_cat     equ 100
basic_line_of_load    equ 110
basic_line_of_save    equ 120
basic_line_of_erase   equ 130
basic_line_of_rename  equ 140

; ==============================================================
; Variables {{{1

; XXX NOTE -- The following two variables
; have to be at a fixed address from the start of the code,
; because they are used by the BASIC loader
; (BASIC sees this code at 0x10000).
svblk_fvar:
; XXX OLD -- used only by the BASIC loader
; Flag used during LOAD, SAVE and DIR commands
; Now its offset is +6.
; XXX TODO -- use a system variable or BC instead?
  dw 0x0000
slen_fvar:
; XXX OLD -- used only by the BASIC loader
; Length of source to be saved
; Now its offset is +8.
  dw 0x0000

; XXX TODO -- move all variables into the code, except those shared with the BASIC loader

ip_fvar: ; XXX TODO -- make it standard
  ; Address of interpreter pointer within source being compiled
  dw 0x0000
dubflag_fvar:
  ; Flag indicating double number
  db 0x00
numbit_fvar:
  ; Temporary store used during number output
  dw 0x0000
endf_fvar:
  ; Temporary store used during number output
  dw 0x0000
etib_fvar: ; XXX OLD -- remove it; adapt the keyboard input code
  ; End address of Terminal Input Buffer
  dw tib_end ; XXX CHECK -- originally tib_start, why?
errhld_fvar:
  ; Address of interpreter pointer position when an error occurred during source compilation
  dw 0x0000
hlds_fvar:
  ; Temporary store during number formatting
  dw 0x0000
pairs_fvar:
  ; Flags to indicate whether pairs such as DO-LOOP match up during compilation
  dw 0x0000
;#smode_fvar: ; XXX CHECK -- why not the system var?
;#; Indicates SAM screen mode 1, 2, 3 or 4
;#  dw 0x0000
len2_fvar:
  ; Used to increase or decrease length of source during editing
  dw 0x0000
len1_fvar:
  ; Used to increase or decrease length of source during editing
  dw 0x0000

; ==============================================================
; Debugging tools {{{1

; Code based on a similar code of "Finen per Imago":
; <http://programandala.net/es.programa.finen_per_imago.html>

debug: equ 0

  macro save_registers
    push iy
    push ix
    push hl
    push de
    push bc
    push af
    exx
    push hl
    push de
    push bc
    push af
    exx
  endm

  macro restore_registers
    exx
    pop af
    pop bc
    pop de
    pop hl
    exx
    pop af
    pop bc
    pop de
    pop hl
    pop ix
    pop iy
  endm

check:

  proc

      local saved_hl
      local message
      local restore
      local print_message
      local return_address

      ld (saved_hl),hl
      pop hl
      ld (message),hl
      save_registers
    message: equ $+1
      ld hl,0
    print_message:
      ld a,(hl)
      inc hl
      and a ; end of text?
      jr z,restore
      call print_a
      jr print_message
    restore:
      ld (return_address),hl
      restore_registers

    saved_hl: equ $+1
      ld hl,0
    return_address: equ $+1
      jp 0

  endp

  macro check,  message,condition
    ;if (nul condition) ? check : check or condition ; XXX FIXME
    if debug
      call check
      db message
      db 0 ; end of message
    endif
  endm

check.char.a:
  save_registers
  call print_a
  restore_registers
  ret

  macro check.char.a
    if debug
      call check.char.a
    endif
  endm

check.print_bc_chars_at_hl:
  push bc
  push hl
  ld a,"{"
  call print_a
  pop hl
  pop bc
  call print_bc_chars_at_hl
  ld a,"}"
  call print_a
  ret

check.cstring.hl:
  save_registers
  ld a,(hl)
  ld b,0
  ld c,a
  inc hl
  call check.print_bc_chars_at_hl
  restore_registers
  ret

  macro check.cstring.hl
    ; print the counted string at HL
    if debug
      call check.cstring.hl
    endif
  endm

check.string.de_b:
  save_registers
  ld c,b
  ld b,0
  ex de,hl
  call check.print_bc_chars_at_hl
  restore_registers
  ret

  macro check.string.de_b
    ; print B characters at DE
    if debug
      call check.string.de_b
    endif
  endm

  macro border,color
    ; change the border to color
    if 0;debug
      push af
      ld a,color
      out (0xfe),a
      pop af
    endif
  endm

; ==============================================================
; Data zones {{{1

; XXX TODO -- choose better names for the bounds

tib_start:
  defs 0x80 ; XXX TODO -- increase after Forth-2012
tib_end:

pad_start:
  defs 0xff

if data_stack_method = hl_dsm
  ; Force the data stack range from 0x??00 to 0x??ff
  ; in order to make the under/overflow checks faster.
  org ($+0x0100) and 0xff00
endif
data_stack_max_top:
  ; The data stack grows from bottom (high memory) to top (low memory)
  defs 0x0100
data_stack_bottom:

return_stack_max_top:
  ; The return stack grows from bottom (high memory) to top (low memory)
  defs 0x0100
return_stack_bottom:

; ==============================================================
; Data stack manipulation {{{1

init_data_stack:
  if data_stack_method = ix_dsm
    ld ix,(sp0)
  else
    ld hl,(sp0)
    ld (dsp),hl
  endif
  ret

; --------------------------------------------------------------
if data_stack_method = sp_dsm ; {{{2

; This is the method used by SamForth.
; Slow versions are the original ones.
; Fast versions have no checks.

push_hl:

if safe_mode

                              ; T Cycles
  push hl                     ;  11
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  push hl                     ;  11
  ld hl,data_stack_max_top    ;  10
  sbc hl,sp                   ;  15
  jp nc,stack_full_error      ;  01 (if no jump)
  ld (dsp),sp                 ;  20
rsp_copy: equ $+1
  ld sp,return_stack_bottom   ;  10
  pop hl                      ;  10
  ret                         ;  10
                              ; 138 Total

else

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  push hl                     ;  11
  ld (dsp),sp                 ;  20
rsp_copy: equ $+1
  ld sp,return_stack_bottom   ;  10
  ret                         ;  10
                              ;  91 Total

endif

pop_hl:

if safe_mode

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  ld hl,(sp0)                 ;  20
  sbc hl,sp                   ;  15
  jp z,stack_empty_error ;  01 (if no jump)
  pop hl                      ;  10
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 136 Total
else

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  pop hl                      ;  10
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 100 Total

endif

push_de_hl:

if safe_mode

                              ; T Cycles
  push hl                     ;  11
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  push de                     ;  11
  push hl                     ;  11
  ld hl,data_stack_max_top    ;  10
  sbc hl,sp                   ;  15
  jp nc,stack_full_error ;  01 (if no jump)
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  pop hl                      ;  10
  ret                         ;  10
                              ; 159 Total
else

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  push de                     ;  11
  push hl                     ;  11
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 102 Total
endif

pop_hl_de:

if safe_mode

  ; Modified SamForth's version, with one check
                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  ld hl,(sp0)                 ;  20
  sbc hl,sp                   ;  15
  jp z,stack_empty_error ;  01 (if no jump)
  pop hl                      ;  10
  pop de                      ;  10
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 146 Total

else

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  pop hl                      ;  10
  pop de                      ;  10
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 110 Total

endif

endif ; data_stack_method = sp_dsm

; --------------------------------------------------------------
if data_stack_method = iy_dsm ; {{{2

; XXX -- alternative data stack -- experimental

; no fast/slow variants: no over/underflow checks

push_hl:
                      ; T Cycles
  push iy             ;  15
  ld iy,(dsp)         ;  20
  dec iy              ;  10
  ld (iy),h           ;  19
  dec iy              ;  10
  ld (iy),l           ;  19
  ld (dsp),iy         ;  20
  pop iy              ;  14
  ret                 ;  10
                      ; 137 total

pop_hl:
  push iy
  ld iy,(dsp)
  ld l,(iy)
  inc iy
  ld h,(iy)
  inc iy
  ld (dsp),iy
  pop iy
  ret

push_de_hl:
  push iy
  ld iy,(dsp)
  dec iy
  ld (iy),d
  dec iy
  ld (iy),e
  dec iy
  ld (iy),h
  dec iy
  ld (iy),l
  ld (dsp),iy
  pop iy
  ret

pop_hl_de:
  push iy
  ld iy,(dsp)
  ld l,(iy)
  inc iy
  ld h,(iy)
  inc iy
  ld e,(iy)
  inc iy
  ld d,(iy)
  inc iy
  ld (dsp),iy
  pop iy
  ret

endif ; data_stack_method = iy_dsm

; --------------------------------------------------------------
if data_stack_method = hl_dsm ; {{{2

push_hl:

if safe_mode

                              ; T Cycles
  push af                     ;  11
  push hl                     ;  11
  push de                     ;  11
  ex de,hl                    ;  04
  ld hl,(dsp)                 ;  20
  dec hl                      ;  06
  ld a,l                      ;  09
  and a                       ;  04
  jp z,stack_full_error  ;  01 (if no jump)
  ld (hl),d                   ;  07
  dec hl                      ;  06
  ld (hl),e                   ;  07
  ld (dsp),hl                 ;  16
  pop de                      ;  10
  pop hl                      ;  10
  pop af                      ;  10
  ret                         ;  10
                              ; 146 Total

else

                              ; T Cycles
  push hl                     ;  11
  push de                     ;  11
  ex de,hl                    ;  04
  ld hl,(dsp)                 ;  20
  dec hl                      ;  06
  ld (hl),d                   ;  07
  dec hl                      ;  06
  ld (hl),e                   ;  07
  ld (dsp),hl                 ;  16
  pop de                      ;  10
  pop hl                      ;  10
  ret                         ;  10
                              ; 118 Total

endif

pop_hl:

if safe_mode

  push af
  push de
  ld hl,(dsp)
  ld e,(hl)
  inc hl
  ld a,l
  and a
  jp z,stack_empty_error
  ld d,(hl)
  inc hl
  ld (dsp),hl
  ex de,hl
  pop de
  pop af
  ret

else

  push de
  ld hl,(dsp)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (dsp),hl
  ex de,hl
  pop de
  ret

endif

push_de_hl:

if safe_mode

  push af
  push de
  push hl
  ld hl,(dsp)
  dec hl
  ld a,l
  and a
  jp z,stack_full_error
  ld (hl),d
  dec hl
  ld (hl),e
  dec hl
  pop de
  ld (hl),d
  dec hl
  ld (hl),e
  ld (dsp),hl
  pop hl
  ex de,hl
  pop af
  ret

else

  push de
  push hl
  ld hl,(dsp)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  dec hl
  pop de
  ld (hl),d
  dec hl
  ld (hl),e
  ld (dsp),hl
  pop hl
  ex de,hl
  ret

endif

pop_hl_de:

if safe_mode

  push af
  ld hl,(dsp)
  ld e,(hl)
  inc hl
  ld a,l
  and a
  jp z,stack_empty_error
  ld d,(hl)
  push de
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (dsp),hl
  pop hl
  pop af
  ret

else

  ld hl,(dsp)
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (dsp),hl
  pop hl
  ret

endif

endif ; data_stack_method = hl_dsm

; --------------------------------------------------------------
if data_stack_method = ix_dsm ; {{{2

; `ix` always holds the data stack pointer. This is the fastest method.

; no fast/slow variants: no over/underflow checks

push_hl:
                      ; T Cycles
  dec ix              ;  10
  ld (ix),h           ;  19
  dec ix              ;  10
  ld (ix),l           ;  19
  ret                 ;  10
                      ; 068 total

pop_hl:
  ld l,(ix)
  inc ix
  ld h,(ix)
  inc ix
  ret

push_de_hl:
  dec ix
  ld (ix),d
  dec ix
  ld (ix),e
  dec ix
  ld (ix),h
  dec ix
  ld (ix),l
  ret

pop_hl_de:

  ld l,(ix)
  inc ix
  ld h,(ix)
  inc ix
  ld e,(ix)
  inc ix
  ld d,(ix)
  inc ix
  ret

endif ; data_stack_method = ix_dsm

; ==============================================================
; Keyboard input {{{1

; XXX TODO convert to `accept`

cursor_address:
  ; Address of the cursor in the input buffer
  dw 0x0000
chars_on_the_left_of_the_cursor:
  ; Length of the input line before the cursor
  db 0x00
chars_on_the_right_of_the_cursor:
  ; Length of the input line after the cursor
  db 0x00

keyboard_input:

  ; Init
  ld hl,(tib_address)
  ld (cursor_address),hl
  xor a
  ld (chars_on_the_left_of_the_cursor),a
  ld (chars_on_the_right_of_the_cursor),a

  if not whole_screen
    ld a,0x01 ; usually channel "K", lower screen I/O
    call link.a
    call rom_cls_lower
  endif

keyboard_input.next_key:
  push hl
  call refresh_the_command_line
  call key_
  call pop_hl
  ; XXX TODO get the control char routine from a table
  ld a,l ; key code
  pop hl

  if false

  cp 128 ; ASCII?
  jp nc,keyboard_input.next_key ; not ASCII
  cp " " ; printable?
  jr c,printable_char ; yes
  ; control char
  cp 15 ; not used control char (>14)?
  jp nc,keyboard_input.next_key ; yes
  cp 6 ; not used control char (<6)?
  jp c,keyboard_input.next_key ; yes

  ; XXX TODO jump table here

  else

;  cp 0x00 ; XXX TODO adapt, how?
;  jp z,keyboard_input.delete_right
;  cp 0x00 ; XXX TODO adapt, how?
;  jp z,keyboard_input.delete_until_end_of_line
  cp caps_char ; 6
  jp z,toggle_caps_lock
  cp edit_char ; 7
  jp z,keyboard_input
  cp cursor_left_char ; 8
  jp z,keyboard_input.cursor_left
  cp cursor_right_char ; 9
  jp z,keyboard_input.cursor_right
  cp cursor_down_char ; 10
  jp z,keyboard_input.cursor_down
  cp cursor_up_char ; 11
  jp z,keyboard_input.cursor_up
  cp delete_left_char ; 12
  jp z,keyboard_input.delete_left
  cp cr_char ; 13
  jp z,keyboard_input.cr
  cp extended_mode_char ; 14 ; XXX TMP
  jp z,toggle_overwrite_mode
  cp 128 ; ASCII?
  jp nc,keyboard_input.next_key ; not ASCII

  endif

  ; XXX FIXME -- strange things happen
printable_char:
  ; a = char code
  push af
overwrite_mode_flag: equ $+1
  ld a,0 ; 0 or 1
  and a ; ovewrite mode?
  call z,sub_4f54h ; no
  ; insert mode
  pop af
  ld (hl),a
  inc hl
  ld (cursor_address),hl
  ld a,(chars_on_the_left_of_the_cursor)
  inc a
  ld (chars_on_the_left_of_the_cursor),a
  ld a,(overwrite_mode_flag)
  and a
  jr z,keyboard_input.next_key
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jr z,keyboard_input.next_key
  dec a
  ld (chars_on_the_right_of_the_cursor),a
  jp keyboard_input.next_key

toggle_caps_lock:
  ld a,(sys_flags2)
  xor 0x08
  ld (sys_flags2),a
  jp keyboard_input.next_key

keyboard_input.cr:
  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld c,a
  ld b,0x00
  add hl,bc
  ld (hl),cr_char
  ld (etib_fvar),hl

  if not whole_screen
    call rom_cls_lower
    ld a,0x02 ; usually channel "S", upper screen I/O
    call link.a
  endif

  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c

  if whole_screen

    ret

  else

    ld b,0x00
    jp print_bc_chars_at_hl_or_nothing

  endif

keyboard_input.delete_left:
  ld a,(chars_on_the_left_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_left_of_the_cursor),a
  ld hl,(cursor_address)
  ld d,h
  ld e,l
  dec de
  ld (cursor_address),de
  ld a,(chars_on_the_right_of_the_cursor)

keyboard_input.move_a_chars_from_hl_to_de:
  and a
  jr z,keyboard_input.no_move_needed
  ld c,a
  ld b,0x00
  ldir
keyboard_input.no_move_needed:
  ld hl,(cursor_address)
  jp keyboard_input.next_key

keyboard_input.delete_right:
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_right_of_the_cursor),a
  ld hl,(cursor_address)
  inc hl
  ld de,(cursor_address)
  jp keyboard_input.move_a_chars_from_hl_to_de

keyboard_input.cursor_left:
  ld a,(chars_on_the_left_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_left_of_the_cursor),a
  ld a,(chars_on_the_right_of_the_cursor)
  inc a
  ld (chars_on_the_right_of_the_cursor),a
  dec hl
  ld (cursor_address),hl
  jp keyboard_input.next_key

keyboard_input.cursor_right:
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_right_of_the_cursor),a
  ld a,(chars_on_the_left_of_the_cursor)
  inc a
  ld (chars_on_the_left_of_the_cursor),a
  inc hl
  ld (cursor_address),hl
  jp keyboard_input.next_key

keyboard_input.delete_until_end_of_line:
  xor a
  ld (chars_on_the_right_of_the_cursor),a
  jp keyboard_input.next_key

keyboard_input.cursor_up:
  ; goto the start of the line
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld (chars_on_the_right_of_the_cursor),a
  xor a
  ld (chars_on_the_left_of_the_cursor),a
  ld hl,(tib_address)
  ld (cursor_address),hl
  jp keyboard_input.next_key

keyboard_input.cursor_down:
  ; goto the end of the line
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld (chars_on_the_left_of_the_cursor),a
  ld c,a
  xor a
  ld (chars_on_the_right_of_the_cursor),a
  ld b,0x00
  ld hl,(tib_address)
  add hl,bc
  ld (cursor_address),hl
  jp keyboard_input.next_key

sub_4f54h:
  ; XXX TODO -- document
  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld c,a
  ld b,0x00
  add hl,bc
  ld (etib_fvar),hl
  ld a,(chars_on_the_right_of_the_cursor)
  inc a
  ld c,a
  ld de,(etib_fvar)
  inc de
  lddr
  ld hl,(cursor_address)
  ret

toggle_overwrite_mode:
  ld a,(overwrite_mode_flag)
  xor 0x01
  ld (overwrite_mode_flag),a
  jp keyboard_input.next_key

refresh_the_command_line:

  if whole_screen

    ld a,(chars_on_the_left_of_the_cursor)
    and a
    jr z,line_cleared
    inc a
    ld b,a
  backspace_to_left_margin:
    push bc
    ld a,backspace_char
    call print_a
    pop bc
    djnz backspace_to_left_margin

  else

    call home_ ; bottom screen

  endif

line_cleared:
  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  and a
  jr z,print_cursor
  ld c,a
  ld b,0x00
  call print_bc_chars_at_hl
print_cursor:
  ld hl,cursor
  ld a,(overwrite_mode_flag)
  and a
  jr nz,print_cursor.do
  inc hl
print_cursor.do:
  ld a,(hl)
  call print_a
  ld hl,(cursor_address)
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jr z,print_trailing_space
  ld c,a
  ld b,0x00
  call print_bc_chars_at_hl
print_trailing_space:
  jp space_ ; needed when a char has been deleted

cursor:
  db "X" ; overwrite mode ; XXX TMP!
  db "_" ; insert mode

; ==============================================================
; Text output {{{1

print_bc_chars_at_hl:
  ; XXX TODO-- faster version por 0-255 chars?
  ld a,(hl)
  inc hl
  push hl
  push bc
  call print_a
  pop bc
  pop hl
  dec bc
print_bc_chars_at_hl_or_nothing:
  ld a,b
  or c
  jr nz,print_bc_chars_at_hl
  ret

print_inline_message:
  ; Print a message stored rigth after the call.
  ; The message has the bit 7 of its last char set.
  ; XXX TODO -- use counted strings instead
  pop hl
  call print_message_at_hl
  jp (hl)

print_table_message:
  ; Print the A-th message (zero is the first) of a table stored at HL.
  ; Every message in the table has the bit 7 of its last char set.
  dec a
  jr z,print_message_at_hl
  ex af,af'
skip_message:
  ld a,(hl)
  inc hl
  and 0x80
  jr z,skip_message
  ex af,af'
  jr print_table_message

print_message_at_hl:
  ; Print a message stored at HL.
  ; The message has the bit 7 of its last char set.
  ld a,(hl)
  inc hl
  bit 7,a
  push af
  res 7,a
  call print_a
  pop af
  jr z,print_message_at_hl
  ; hl = address after the last char
  ret

wrap_print_message_at_hl:
  ; Print (left justified) a message stored at HL.
  ; The message has the bit 7 of its last char set.

  ; XXX TODO

wrap_print_message_at_hl.next_word:

  push hl ; save the start address
  ld b,0x0 ; char count

wrap_print_message_at_hl.next_char:
  ld a,(hl)
  inc hl
  inc b
  bit 7,a
  res 7,a
  jr nz,wrap_print_message_at_hl.end_of_message_found
  cp space_char
  jr nz,wrap_print_message_at_hl.next_char

wrap_print_message_at_hl.end_of_word_found:

  ; inc ; XXX TODO
  jr z,wrap_print_message_at_hl.next_char

wrap_print_message_at_hl.end_of_message_found:

; wrap_print_message_at_hl.next_word: ; XXX TODO
  pop hl

  ; hl = message address
  ; b = message length

  ret

; ==============================================================
; Errors {{{1

; XXX TODO -- move to `throw`
stack_empty_error:
  ld a,0x01
  jr error_a
stack_full_error:
  ld a,0x02
  jr error_a
undefined_word_error:
  ; XXX TODO -- print the offending word
  ld a,0x03
  jr error_a
compile_only_error:
  ; XXX TODO -- print the offending word
  ld a,0x04
  jr error_a
division_by_zero_error:
  ld a,0x05
  jr error_a
return_stack_full_error:
  ld a,0x06
  jr error_a
inside_fence_error:
  ld a,0x07
  jr error_a
break_error:
  ld a,0x08
  jr error_a
unstructured_error:
  ; XXX TODO -- print the offending word
  ld a,0x09
  jr error_a
not_found_error:
  ; XXX TODO -- print the offending word
  ld a,0x0a
  jr error_a
empty_name_error:
  ld a,0x0b
  jr error_a

; XXX NEW routine ,0x1d bytes, longer, but one byte less per message
; XXX TODO -- convert to error_hl ?
error_a:
; XXX TODO -- print error number too:
;;  push af
;;  call cr_
;;  call dot_
  ld hl,error_messages
  call print_table_message

  ; init after an error
  ;;check "init after an error"
  ; XXX TODO -- factor this
  call init_data_stack
  ;;check "init after an error -- aftor call init_data_stack"
  ld (svblk_fvar),a
  ld hl,(ip_fvar)
  ld (errhld_fvar),hl
;; XXX ? -- not needed?:
  ld hl,tib_start
  ld (tib_address),hl
  ld hl,pad_start
  ld (pad_address),hl
  ;;check "init after an error -- before call restore_dictionary_pointers"
  call restore_dictionary_pointers
  ;;call cr_ ; XXX ? --- needed?
  xor a
  ld (dubflag_fvar),a
  ;;check "init after an error -- before jp quit_"
  jp quit_

; XXX TODO -- move the messages to their own file and ram page
error_messages:
  db "Stack empt" ; Error number 0x01 ; XXX -- -4 in ANS Forth
  db "y"+0x80
  db "Stack ful" ; Error number 0x02 ; XXX -- -3 in ANS Forth
  db "l"+0x80
  db "Undefined wor" ; Error number 0x03 ; XXX -- -13 in ANS Forth
  db "d"+0x80
  db "Interpreting a compile-only wor" ; Error number 0x04 ; XXX -- -14 in ANS Forth
  db "d"+0x80
  db "Division by zer" ; Error number 0x05 ; XXX -- -10 in ANS Forth
  db "o"+0x80
  db "Return stack ful" ; Error number 0x06 ; XXX -- not used -- -5 in ANS Forth
  db "l"+0x80
  db "Inside fenc" ; Error number 0x07 ; XXX -- -15 in ANS Forth "invalid FORGET"
  db "e"+0x80
  db "Brea" ; Error number 0x08 ; XXX -- not used, not in ANS Forth
  db "k"+0x80
  db "Unstructure" ; Error number 0x09 ; XXX -- -10 in ANS Forth
  db "d"+0x80
  db "Not foun" ; Error number 0x0a ; XXX -- used only by `;` -- (-13 in ANS Forth?)
  db "d"+0x80
  db "Attempt to use zero-lenght string as a nam" ; Error number 0x0b ; XXX -- -16 in ANS Forth
  db "e"+0x80
;  db "Return stack empt" ; XXX -- not used yet ; xxx -- -6 in ANS Forth
;  db "y"+0x80

; ==============================================================
; Entry points  {{{1

cold_start:
  di
  ld (saved_basic_sp),sp
  ld sp,(rp0)
  ei
  ld a,0x02 ; usually channel "S", upper screen I/O
  call link.a
  jp cold_

warm_start:
  di
  ld (saved_basic_sp),sp
  ld sp,(rp0)
  ei
  jp quit_

; ==============================================================
; Dictionary tools {{{1

save_dictionary_pointers:
  ld hl,(dp)
  ld (saved_dp),hl
  ld hl,(latest)
  ld (saved_latest),hl
  ret

restore_dictionary_pointers:
  ; XXX -- called only after an error, but maybe useful in the future (e.g. for `catch`)
saved_dp: equ $+1
  ld hl,0
  ld (dp),hl
saved_latest: equ $+1
  ld hl,0
  ld (latest),hl
  ret

; XXX TODO -- factor to a word (`?struc`, `?pairs` ?)
; XXX TODO -- rename the original "sub_5743h" name in SamForth
structured:
  ; (sp) = flow structure code compiled in the current word
  ; a = flow structure code to compare
  call pop_hl
  cp l
  jp nz,unstructured_error
  ret

; ==============================================================
; Dictionary {{{1

_previous_nfa: defl 0

  macro header, label_,name,flags,previous ; {{{2

    ; Create a word header in the dictionary

    ; label = label-format name (with a "_" suffix)
    ; name = string with the actual name
    ; flags = byte with the precedence and compile-only bits combined

    label_##flags_field:  db flags
    label_##lfa:          dw _previous_nfa
    _previous_nfa:        defl $
    label_##nfa:          db label_##cfa-$-1,name
    label_:
    label_##cfa:

  endm

  ; In order to document the origin of a word, or the most recent Forth
  ; standard it is based on, the following notation is used in the word
  ; comments, above the header definition:

  ; 2012    = Forth-2012 (2012)
  ; 79      = Forth-79 (1979)
  ; 83      = Forth-83 (1983)
  ; ace     = Jupiter Ace's Ace Forth (1982)
  ; af      = ZX Spectrum's Abersoft Forth (1983)
  ; 94      = Forth-94 (ANS Forth, ISO Forth) (1994)
  ; comus   = Common use
  ; cf      = Couplement Forth specific
  ; fig     = FIG Forth 1.1 (1979)
  ; gforth  = Gforth
  ; hist    = historical: present in the language from the start ; XXX TODO -- remove?
  ; sf      = SamForth ; XXX TODO -- remove?

; --------------------------------------------------------------
  ;: couplement_forth ( -- ) cf ; {{{2
  ;:
  ;: Noop word. If present, the program is running on Couplement Forth.
  ;: Intended for conditional compilation in portable programs.

  header couplement_forth_,"couplement-forth",0

  ret

; --------------------------------------------------------------
  ;: (bootmessage) ( -- ) cf,gforth ; {{{2
  ;:
  ;: Print the Couplement Forth boot message.

  header paren_bootmessage_,"(bootmessage)",0

  call print_inline_message
  db "Couplement Forth",cr_char
  version
  db cr_char
  db "By Marcos Cruz",cr_char
  db "(programandala.net), 2015, 2016,",cr_char
  db "2020",cr_char+0x80
  ret

; --------------------------------------------------------------
  ;: bootmessage ( -- ) cf,gforth ; {{{2
  ;:
  ;: Print a boot message (Couplement Forth's boot message by default).
  ;: The behaviour of `bootmessage` can be changed with `is`.

  header bootmessage_,"bootmessage",0

  jp paren_bootmessage_

; --------------------------------------------------------------
  ;: clit ( -- b )
  ;:
  ;: Push the content of the next address unit to the data stack as a literal.

  header c_lit_,"clit",0

  pop hl ; address of the literal
  ld e,(hl)
  ld d,0
  inc hl
  push hl ; return address
  ex de,hl
  jp push_hl

; --------------------------------------------------------------
  ;: lit ( -- x ) fig,comus,gforth ; {{{2
  ;:
  ;: Push the content of the next cell to the data stack as a literal.

  header lit_,"lit",0

  pop hl ; address of the literal
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  push hl ; return address
  ex de,hl
  jp push_hl

; --------------------------------------------------------------
  ;: literal ( compilation: x -- ) ( run-time: -- x ) 2012 ; {{{2
  ;:
  ;:  Interpretation: Interpretation semantics for this word are undefined.
  ;:  Compilation: ( x -- )
  ;:    Append the run-time semantics given below to the current definition.
  ;:  Run-time: ( -- x )
  ;:    Place x on the stack.

  header literal_,"literal",immediate+compile_only

  ; XXX TODO -- write
  ld de,lit_
  call compile_call_de
  ; hl = dp
  call pop_hl ; XXX TODO -- use pop_de instead
  ex de,hl
  jp compile_de

; --------------------------------------------------------------
  ;: >body ( cfa -- pfa ) 94 ; {{{2
  ;:
  ;:  XXX TODO -- doc
  ;: ( xt -- a-addr ) a-addr is the data-field address corresponding to xt. ; {{{2
  ;:  An ambiguous condition exists if xt is not for a word defined via CREATE.

  header to_body_,">body",0

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      inc hl
      inc hl
      inc hl
      ld (ix),h
      dec ix
      ld (ix),l
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      inc de
      inc de
      inc de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    inc hl
    inc hl
    inc hl
    jp push_hl
  endif

; --------------------------------------------------------------
  ;: 2- ( n1|u1 -- n2|u2 ) comus ; {{{2
  ;:
  ;:  Subtract two (2) from n1|u1 giving the difference n2|u2.

  header two_minus_,"2-",0

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      dec hl
      dec hl
      ld (ix),h
      dec ix
      ld (ix),l
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      dec de
      dec de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    dec hl
    dec hl
    jp push_hl
  endif

; --------------------------------------------------------------
  ;: 2+ ( n1|u1 -- n2|u2 ) comus ; {{{2
  ;:
  ;:  Add two (2) to n1|u1 giving the sum n2|u2.

  header two_plus_,"2+",0

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      inc hl
      inc hl
      ld (ix),h
      dec ix
      ld (ix),l
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      inc de
      inc de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    inc hl
    inc hl
    jp push_hl
  endif

; --------------------------------------------------------------
  ;: 1- ( n1|u1 -- n2|u2 ) 94 ; {{{2
  ;:
  ;:  Subtract one (1) from n1|u1 giving the difference n2|u2.

  header one_minus_,"1-",0

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      dec hl
      ld (ix),h
      dec ix
      ld (ix),l
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      dec de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    dec hl
    jp push_hl
  endif

; --------------------------------------------------------------
  ;: 1+ ( n1|u1 -- n2|u2 ) 94 ; {{{2
  ;:
  ;:  Add one (1) to n1|u1 giving the sum n2|u2.

  header one_plus_,"1+",0

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      inc hl
      ld (ix),h
      dec ix
      ld (ix),l
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      inc de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    inc hl
    jp push_hl
  endif

; --------------------------------------------------------------
  ;: execute ( cfa -- ) 94 ; {{{2

  header execute_,"execute",0

  call pop_hl
  jp (hl)

; --------------------------------------------------------------
  ;: perform ( a -- ) cf ; {{{2

  header perform_,"perform",0

  call pop_hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  ret z
  jp (hl)

; --------------------------------------------------------------
  ;: prompt ( -- ) ( R: i*x -- ) gforth ; {{{2
  ;:
  ;: Print the system prompt.

  header prompt_,"prompt",0

  ; XXX TODO -- Gforth prints "compiled" in compiling state.
  call print_inline_message
  db " o"
  db "k"+0x80
  ret

; --------------------------------------------------------------
  ;: quit ( -- ) ( R: i*x -- ) 94 ; {{{2
  ;:
  ;: Empty the return stack, store zero in `source-id` if it is present, make
  ;: the user input device the input source, and enter interpretation state.
  ;: Do not display a message.  Repeat the following:
  ;:
  ;: - Accept a line from the input source into the input buffer, set `>in` to
  ;: zero, and interpret.
  ;:
  ;: - Display the implementation-defined system prompt if in interpretation
  ;: state, all processing has been completed, and no ambiguous condition
  ;: exists.

  header quit_,"quit",0

  ; clear the return stack:
  di ; XXX ? -- needed?
  ld sp,(rp0) ; reset the return stack
  ei ; XXX ? -- needed?
  ; store zero in `source-id` ; XXX TODO
  ; make the user input device the input source ; XXX TODO
  ; enter intepretation state:
  call left_bracket_

quit.do:
;;  check "before call keyboard_input"
  call cr_
  call keyboard_input ; XXX TODO -- this will depend on the current input source
  call space_
  ; XXX TODO -- set `>in` to zero
;;  check "before call interpret_"
  call interpret_
  ld a,(state)
  and a ; compiling?
  call z,prompt_
  jp quit.do

; --------------------------------------------------------------
  ;: branch ( -- ) comus ; {{{2

  header branch_,"branch",0

  pop hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ret

; --------------------------------------------------------------
  ;: ?branch ( f -- ) ; {{{2

  header question_branch_,"?branch",0

  call pop_hl
  ld a,l
  cp h
  jp nz,branch_
  pop hl
  inc hl
  inc hl
  jp (hl)

; --------------------------------------------------------------
  ;: 0branch ( f -- ) ; {{{2

  header zero_branch_,"0branch",0

  call pop_hl
  ld a,l
  cp h
  jp z,branch_
  pop hl
  inc hl
  inc hl
  jp (hl)

; --------------------------------------------------------------
  ;: swap ( x1 x2 -- x2 x1 ) hist,94 ; {{{2

  header swap_,"swap",0

  call pop_hl_de
  ex de,hl
  jp push_de_hl

; --------------------------------------------------------------
  ;: dup ( x -- x x ) hist,94 ; {{{2
  ;:
  ;: Duplicate the cell on the top of the stack.

  header dup_,"dup",0

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld e,(ix+0)
      ld d,(ix+1)
      ld (ix-1),d
      ld (ix-2),e
      dec ix
      dec ix
      ret
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      ex de,hl
      call push_hl
      jp push_hl
    endif
  else
    call pop_hl
    call push_hl
    jp push_hl
  endif

; --------------------------------------------------------------
  ;: ?dup ( x -- 0 | x x ) hist,94 ; {{{2
  ;:
  ;: Duplicate the cell on the top of the stack if it is non-zero.

  header question_dup_,"?dup",0

  call pop_hl ; XXX TODO -- faster: just read it, don't pop
  ld a,h
  or l
  call nz,push_hl
  jp push_hl

; --------------------------------------------------------------
  ;: nip ( x1 x2 -- x2 )

  header nip_,"nip",0

  call pop_hl
  push hl
  call pop_hl
  pop hl
  jp push_hl

; --------------------------------------------------------------
  ;: drop ( x -- ) hist,94 ; {{{2

  header drop_,"drop",0

  if data_stack_method = ix_dsm
    inc ix
    inc ix
    ret
  else
    jp pop_hl
  endif  

; --------------------------------------------------------------
  ;: interpret ( -- )

  header interpret_,"interpret",0

  ld hl,(tib_address)
  dec hl
interpret.skip_space:
  ;;check "at interpret.skip_space"
  ; hl = address of the last char parsed
  inc hl
  ld a,(hl)
  cp space_char
  jp z,interpret.skip_space ;
;  cp standard_tab_char ; XXX TODO -- experimental
;  jr z,interpret.skip_space
  cp cr_char
  ret z

  ; First char to interpret found
  ; XXX TODO -- "inc hl" here would save one loop in "(find)"
  ld (ip_fvar),hl ; XXX TODO -- use "ex de,hl"...
  call paren_find_ ; XXX TODO -- ...and use other entry point
  call pop_hl
  ; hl = cfa or zero
  ld a,h
  or l
  jp nz,interpret.word_found

  ; the word was not found
  check "the word was not found "
  ld hl,(ip_fvar)
  call number_hl
  ld hl,(numbit_fvar) ; XXX TODO -- check if this variable is actually needed
  ld (ip_fvar),hl
  call pop_hl
  ld a,h
  or l
  jp z,l520ah
  ld a,0x01 ; XXX OLD -- not needed, because A<>0 ; XXX TODO --
  ld (dubflag_fvar),a
  call push_hl
l520ah:
  ld a,(state)
  and a ; executing?
  jp z,l5242h ; jump if executing
  ; compiling:
  ld a,(dubflag_fvar)
  cp 0x01 ; XXX OLD ; XXX TODO --
;  and a ; XXX NEW ; XXX TODO --
  jp nz,l521fh
  call pop_hl_de
  ex de,hl
  call push_de_hl
l521fh:
  call pop_hl
  ld b,h
  ld c,l
  ld hl,lit_
  call push_hl
  call compile_call_tos
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ld a,(dubflag_fvar)
  cp 0x01 ; XXX OLD ; XXX TODO --
;  and a ; XXX NEW ; XXX TODO --
  jp nz,l5242h
  xor a
  ld (dubflag_fvar),a
  jp l521fh
l5242h:
  ld hl,(ip_fvar)
  jp interpret.skip_space

interpret.word_found:
  check "interpret.word_found:"
  ; hl = nfa of the word found
flags_field: equ $+1
  ld a,0
  bit precedence_bit,a
  jp nz,interpret.execute

  ; it's not an immediate word
  ld a,(state)
  and a ; compiling?
  jp nz,interpret.compile_non_immediate_word

  ; compiling a not immediate word
  ld a,(flags_field)
  bit compile_only_bit,a ; compile-only?
  jp z,interpret.execute
  ; it's not a compile word
  ld a,(state)
  and a ; compiling?
  jp z,compile_only_error

interpret.execute:
  ; execute the word
  ;;check "execute the word"
  call push_hl ; XXX TODO -- remove...
  ;;check "before call execute_"
  call execute_ ; XXX TODO -- ...and execute the word directly
  ;;check "after call execute_"
  ld hl,(ip_fvar)
  ;;check "before jp interpret.skip_space"
  jp interpret.skip_space

interpret.compile_non_immediate_word:
  ; compiling a non-immediate word
  ld a,(flags_field)
  bit compile_only_bit,a ; compile-only?
  jp nz,interpret.execute
  call push_hl
  call compile_call_tos
  ld hl,(ip_fvar)
  jp interpret.skip_space

  ; XXX TODO -- factor:
compile_de:
  ld hl,(dp)
  jp compile_de_at_hl

compile_call_tos:
  call pop_hl
  ex de,hl

compile_call_de:
  ld hl,(dp)
  ld (hl),0xcd ; Z80 `call`
  inc hl

compile_de_at_hl:
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  ;: (find) ( -- 0 | cfa )

  header paren_find_,"(find)",0

  ld de,(ip_fvar) ; address of the name to be searched for
  ;;push de ; XXX TMP -- debugging
  ld b,0x00 ; char count

  ; XXX TODO -- study: use HL and A instead of DE and B, to save commands later:
paren_find.parse_name:
  ld a,(de)
  cp space_char
  jp z,paren_find.name_complete
  cp cr_char
  jp z,paren_find.name_complete
;  cp standard_tab_char ; XXX TODO -- experimental
;  jp z,paren_find.name_complete
  inc b ; char count
  inc de ; point to next char
  jp paren_find.parse_name

paren_find.name_complete:
  ; de = address+1 of the last char of the name ; XXX -- not used
  ; b = name length

  ld de,(ip_fvar) ; XXX TMP -- debugging
;;  check "Name1:"
  check.string.de_b

  ld a,b
  ld (length_of_name_searched_for),a
  ld hl,(latest) ; nfa of the first dictionary word to compare to

compare_the_names:
  ; hl = nfa of a word in the dictionary

;;  cp 1
;;  jr nz,no_check
;;  check "="
  ;check.cstring.hl
;;no_check:

length_of_name_searched_for: equ $+1
  ld a,0x00 ; length of the name searched for
  cp (hl) ; lengths are equal?
  jp nz,the_names_are_different
  ; lengths are equal
;;  check "=L"
  push hl ; save the nfa of the dictionary word
  ld de,(ip_fvar)
  ld b,a
  ; de = address of the name to be searched for
  ; b = its length
;;  check "Name2:"
  check.string.de_b

next_char:
;;  check "next char"
  inc hl
  ; de = address of current char of the name to be searched for
  ; b = its remaining length
  ; hl = address of the current char of a word's name in the dictionary
  ld c,(hl)
  ld a,(de)

  ; convert the char in the A register to lowercase if needed
  cp "A"
  jp c,compare_char ; jump if lower than "A"
  cp "Z"+1
  jp nc,compare_char ; jump if higher than "Z"
  or %100000 ; convert to lowercase

compare_char:
;;  check "Compare:"
  check.char.a
  cp c
  jp nz,one_char_is_different
  inc de
  djnz next_char

  ; the name has been found in the dictionary
  dec de ; XXX NOTE -- needed, checked!
  ld (ip_fvar),de
  pop de ; nfa of the dictionary word
  dec de
  dec de
  dec de ; flags field address of the dictionary word
  ex de,hl
  ld a,(hl) ; contents of the flags field
  ld (flags_field),a ; needed by `interpret` later
  ex de,hl
  inc hl
  ; hl = cfa of the dictionary word
  jp push_hl ; return the cfa of the dictionary word

one_char_is_different:
;;  check "!c"
  pop hl ; restore the nfa of the dictionary word
the_names_are_different:
;;  check "!n"
  ; hl = nfa of the dictionary word
  dec hl ; to high byte of lfa
  ld a,(hl)
  dec hl ; to low byte of lfa
  ld c,(hl)
  ld h,a
  ld l,c
  ; hl = nfa of the previous word, or 0 if end of dictionary
  or l ; end of dictionary?
  jp nz,compare_the_names
  ; end of dictionary
  jp push_hl ; return 0

; --------------------------------------------------------------
  ;: u* ( u1 u2 -- du ) ; XXX TODO -- 2020-05-27: Confirm stack ; {{{2

  header u_mult_,"u*",0

  call pop_hl_de
  ld b,h
  ld a,l
  call sub_5324h
  push hl
  ld h,a
  ld a,b
  ld b,h
  call sub_5324h
  pop de
  ld c,d
  add hl,bc
  adc a,0x00
  ld d,l
  ld l,h
  ld h,a
  jp push_de_hl

sub_5324h:
  ld hl,0x0000
  ld c,0x08
l5329h:
  add hl,hl
  rla
  jp nc,l5330h
  add hl,de
  adc a,0x00
l5330h:
  dec c
  jp nz,l5329h
  ret

; --------------------------------------------------------------
  ;: + ( n1 n2 -- n3 ) hist,94 ; {{{2

  header plus_,"+",0

  call pop_hl_de
  add hl,de
  jp push_hl

; --------------------------------------------------------------
  ;: d+ ( n1 n2 -- d ) ; XXX TODO -- 2020-05-27: Confirm stack ; {{{2

  header d_plus_,"d+",0

  call pop_hl
  ld b,h
  ld c,l
  call pop_hl
  push hl
  call swap_
  call pop_hl
  pop de
  add hl,de
  ex de,hl
  push af
  call pop_hl
  pop af
  adc hl,bc
  jp push_de_hl

; --------------------------------------------------------------
  ;: within ( n1|u1 n2|u2 n3|u3 -- flag ) 2012 ; {{{2
  ;:
  ;: Perform a comparison of a test value n1|u1 with a lower limit n2|u2 and an
  ;: upper limit n3|u3, returning true if either (n2|u2 < n3|u3 and (n2|u2 <=
  ;: n1|u1 and n1|u1 < n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  ;: n3|u3)) is true, returning false otherwise.  An ambiguous condition exists
  ;: if n1|u1, n2|u2, and n3|u3 are not all the same type.

  header within_,"within",0

  ; DZX-Forth:
  ;     pop hl
  ;     pop de
  ;     call hl_minus_de_to_hl
  ;     ex (sp),hl
  ;     call hl_minus_de_to_hl
  ;     jp u_greater.1
  ; Forth-94:
  ;     OVER - >R - R>  U<

  ; XXX checked
  ; XXX TODO faster, in low level
  call over_
  call minus_
  call to_r_
  call minus_
  call r_from_
  jp u_less_

; --------------------------------------------------------------
  ;: - ( n1 n2 -- n3 ) hist,94 ; {{{2

  header minus_,"-",0

  call pop_hl_de
  ex de,hl ; XXX TODO -- remove this and write pop_de_hl
  sbc hl,de
  jp push_hl

; --------------------------------------------------------------
  ;: negate ( n1 -- n2 )

  header negate_,"negate",0

  call pop_hl
  ex de,hl ; XXX TODO -- remove this and write pop_de
  ld hl,0x0000
  sbc hl,de
  jp push_hl

; --------------------------------------------------------------
  ;: dnegate ( d1 -- d2 )

  header d_negate_,"dnegate",0

  call pop_hl_de
  sub a
  sub e
  ld e,a
  xor a
  sbc a,d
  ld d,a
  xor a
  sbc a,l
  ld l,a
  xor a
  sbc a,h
  ld h,a
  jp push_de_hl

; --------------------------------------------------------------
  ;: number ( ca -- n | d ) comus ; {{{2
  ;:
  ;: ca = address of the first char ; XXX ;: TODO -- confirm
  ;:
  ;: Convert the ASCII characters in the input buffer or source code area into
  ;: a double precision number. If the number is below 65536 convert it into a
  ;: single precision number.

  header number_,"number",0

  call pop_hl
number_hl:
  ld a,(hl)
  cp "-"
  jp nz,l53f1h ; not a negative number

  ; negative number
  inc hl
  ld a,0x01 ; XXX TODO -- remove?, because a<>0; check how this flag is used later... no way, several bits are used apart
  ld (negative_number_flags),a

l53f1h:
  xor a
  ld (endf_fvar),a
  ex de,hl
  ld hl,0x0000
  ld (number_part_1),hl
  ld (number_part_2),hl
l5400h:
  ld a,(de)
  cp "0" ; any invalid digit?
;;  check "undefined 1"
  jp c,undefined_word_error
  ld c,a
  ld a,(base)
  ld b,0x0a
  cp b ; base 10?
  jp nc,l5415h
  add a,"0"
  cp c
  check "undefined 2"
  jp c,undefined_word_error
l5415h:
  ld a,c
  cp 0x3a
  jp nc,l5477h
  sub 0x30
l541ch:
  ld h,0x00
  ld l,a
  call push_hl
  inc de
  ld a,(de)
  cp space_char
  jp z,l5470h
  cp 0x0d
  jp z,l5470h
l542ch:
  dec de
  ld (numbit_fvar),de
  ld hl,(number_part_1)
  call push_hl
  ld hl,(base)
  call push_hl
  call u_mult_
  call pop_hl
  ld hl,(base)
  call push_hl
  ld hl,(number_part_2)
  call push_hl
  call u_mult_
  call d_plus_
  call pop_hl
  ld (number_part_1),hl
  call pop_hl
  ld (number_part_2),hl
  ld a,(endf_fvar)
  cp 0x01
  jp z,l53beh
  ld de,(numbit_fvar)
  inc de
  jp l5400h

l5470h:
  ld a,0x01
  ld (endf_fvar),a
  jp l542ch

l5477h:
  ld c,a
  ld a,(base)
  add a,0x37
  cp c
  check "undefined 3"
  jp c,undefined_word_error
  ld a,c
  sub 0x37
  jp l541ch

l53beh:
number_part_1: equ $+1
  ld hl,0x000
number_part_2: equ $+1
  ld de,0x000
  call push_de_hl
negative_number_flags: equ $+1
  ld a,0x00 ; flags for negative number (bits 1 and 7)
  cp 0x01 ; XXX OLD ; XXX TODO --
;;  and a ; XXX NEW ; XXX TODO --
  jp nz,number.return
  ld a,h
  or l
  jp nz,l53d8h
  ld a,0x80 ; XXX OLD ; XXX TODO --
;;  dec a ; a=0xff ; XXX NEW ; XXX TODO --
  ld (negative_number_flags),a

l53d8h:
  call d_negate_
  ld a,(negative_number_flags)
  cp 0x80
  jp nz,number.return
  call pop_hl ; XXX TODO -- call drop instead?
  ld hl,0x0000
  call push_hl

number.return:
  check "number.return"
  xor a
  ld (negative_number_flags),a
  ret

; --------------------------------------------------------------
  ;: space ( -- ) fig,79,83,94 ; {{{2
  ;:
  ;: Display one space.

  header space_,"space",0

  ld a,space_char
  jp print_a

; --------------------------------------------------------------
  ;: spaces ( u -- ) fig ; {{{2
  ;:
  ;: Display u spaces.
  ;:
  ;: Note:
  ;:
  ;: In fig-Forth, the parameter is an unsigned number (u), and the word's
  ;: description is: "Type u spaces.".
  ;:
  ;: In Forth-83, the parameter is a positive number (+n) and the word's
  ;: description is: "Displays +n ASCII spaces.  Nothing is displayed if +n is
  ;: zero.".
  ;:
  ;: In ANS Forth the parameter is a signed number (n) and the word's
  ;: description is: "If n is greater than zero, display n spaces.".
  ;:
  ;: Couplement Forth's `spaces` behaves like fig-Forth's. It's simpler and
  ;: faster and 0..65535 spaces can be printed. When printing 0..32,767 spaces
  ;: U uses an unsigned 16-bit number instead.

  header spaces_,"spaces",0

  call pop_hl
  ld a,l
  or h
  ret z ; exit if no spaces
  ; XXX TODO -- this simple change make the word compatible with ANS Forth and Forth 83:
;;  bit 7,h
;;  ret nz ; exit if negative parameter

spaces.hl:
  push hl
  call space_
  pop hl
  ld a,h
  or l
  dec hl
  jp nz,spaces.hl
  ret

; --------------------------------------------------------------
  ;: emit ( c -- ) 94 ; {{{2

  header emit_,"emit",0

  call pop_hl
  ld a,l
print_a:
  rst 0x10
  ld a,0xff
  ld(sys_scr_ct),a ; no "scroll?" message
  ret

;  include "inc/emit.z80s" ; XXX TODO

; --------------------------------------------------------------
  ;: u. ( u -- )

  header u_dot_,"u.",0

  if data_stack_method = ix_dsm
    push ix
  else
    ld hl,(dsp)
    push hl
  endif
l54a3h:
  ld hl,(base) ; XXX ? -- why here?
  call push_hl ; XXX ? -- and here
  call slash_mod_
  call swap_
  ; XXX TODO -- pop_l or pop_a would be useful here
  call pop_hl ; XXX ? -- why not simply here?
  ld a,0x09
  cp l
  jr c,l54cdh ; base >9?
  ld a,0x30
l54b9h:
  add a,l
  ld l,a
  call push_hl
  call swap_
  call pop_hl
  ld a,h
  or l
  jr z,l54d1h
  call push_hl
  jp l54a3h
l54cdh:
  ld a,0x37
  jp l54b9h
l54d1h:
  pop hl
  if data_stack_method = ix_dsm
    push ix
    pop de
  else
    ld de,(dsp)
  endif
  sbc hl,de
  srl l
  ld b,l
  inc b
l54dch:
  call pop_hl
  ld a,l
  push bc
  call print_a
  pop bc
  djnz l54dch
  jp space_

; --------------------------------------------------------------
  ;: /mod ( n1 n2 -- n3 n4 )
  ;:
  ;: Divide the second single precision number on the stack by the top single
  ;: precision number and leave the modulus (remainder) as second on the stack
  ;: and the quotient on the top of the stack.

  header slash_mod_,"/mod",0

  call pop_hl_de
de_hl_slash_mod:
  ex de,hl
  ld a,d
  or e
  jp z,division_by_zero_error
  and a
  ld b,d
  ld c,e
  ld de,0xffff
de_hl_slash_mod.again:
  inc de
  sbc hl,bc
  jr nc,de_hl_slash_mod.again
  add hl,bc
  ex de,hl
  jp push_de_hl

; --------------------------------------------------------------
  ;: cls ( -- ) zx ; {{{2
  ;:
  ;: XXX TODO
  ;: Clear the screen.

  header cls_,"cls",0

  jp rom_cl_all

;  call rom_cl_all
;  ld a,2
;  jp rom_chan_open

; --------------------------------------------------------------
  ;: create ( "name" -- )

  header create_,"create",0

  ; XXX NEW -- it did nothing
  jp variable_

  ; XXX TODO -- create a word with this:
create_header:

  ; create a header with the name from the input stream

  ld de,(ip_fvar)
create_header.skip_blanks:
  inc de
  ld a,(de)
  cp space_char
  jr z,create_header.skip_blanks
  cp cr_char
  jp z,empty_name_error

  ld hl,(dp)
  ; hl=ffa of the new header
  ld (hl),0
  inc hl
  ; hl=lfa of the new header
  ld bc,(latest)
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ; hl=nfa of the new header

  push de ; start of the new word name
  ld b,0x00 ; char counter
create_header.next_char:
  ld a,(de)
  cp space_char
  jr z,create_header.name_complete
  cp cr_char
  jr z,create_header.name_complete
  inc b
  inc de
  jp create_header.next_char

create_header.name_complete:
  ; (sp) = address of the first char of the name
  ; de = address of the last char of the name
  ; b = name length
  ; hl = nfa of the new header
  ld a,b
  ld (hl),a
  ld (latest),hl
  inc hl ; point to nfa+1 (name address) of the new header
  pop de ; address of the first char of the name

create_header.store_name:
  ; de = address of the first char of the name
  ; hl = nfa+1 (name address) of the new header
  ld a,(de)
  cp "A"
  jr c,create_header.store_char ; jump if lower than "A"
  cp "Z"+1
  jr nc,create_header.store_char ; jump if higher than "Z"
  or %100000 ; convert to lowercase
create_header.store_char
  ld (hl),a
  inc de
  inc hl
  djnz create_header.store_name

  ; hl = next free address in the dictionary,
  ;      and code field address of the new word
  ; de = address after the last char of the name

  ld (dp),hl
  dec de ; XXX ? -- why this?
  ld (ip_fvar),de
  ret

; --------------------------------------------------------------
  ;: noop ( <name> -- ) af,gforth,comus ; {{{2

  header noop_,"noop",0

  ret

; --------------------------------------------------------------
  ;: defer ( <name> -- )

  header defer_,"defer",0

  call create_header
  ld de,noop_
  call compile_jp_de
  jp save_dictionary_pointers

  ; XXX TODO convert this into a word
compile_jp_de:
  ld hl,(dp)
  ld (hl),0xc3 ; Z80 `jp`
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  ;: : ( "name" -- )

  header colon_,":",0

  ; XXX -- this check was useless:
;  ld a,(state)
;  and a ; compiling?
;  jp nz,compile_only_error
  call right_bracket_
  call create_header
  ld l,colon_structure_id
  jp push_hl

; --------------------------------------------------------------
  ;: ; ( colon-sys -- ) ; XXX TODO -- stack ; {{{2

  header semicolon_,";",immediate+compile_only

  call pop_hl
  ld a,colon_structure_id
  cp l
  jp nz,not_found_error ; XXX ? -- why this error message?
  ld hl,(dp)
  ld (hl),0xc9 ; Z80 ret
  inc hl
  ld (dp),hl
  call left_bracket_
  jp save_dictionary_pointers

; --------------------------------------------------------------
  ;: cr ( -- )

  header cr_,"cr",0

  ld a,0x0d
  jp print_a

; --------------------------------------------------------------
  ;: words ( -- ) 94 ; {{{2
  ;:
  ;: List all the words in the context dictionary.

  header words_,"words",0

  ; XXX TODO -- print word info

  check "in words!"

  ld hl,(latest)
words.print_word:
  ; hl = nfa
  push hl
  ld b,0x00
  ld c,(hl)
  inc hl
  call print_bc_chars_at_hl
  call space_
  pop hl ; hl = nfa
  dec hl ; hl = lfa+1
  ld a,(hl)
  dec hl ; hl = lfa
  ld l,(hl)
  ld h,a
  ; hl = nfa of previous word or zero if end of dictionary
  or l ; end of dictionary?
  jr nz,words.print_word ; no
  ret

; --------------------------------------------------------------
  ;: base ( n -- )

  header base_,"base",0

  call do_variable
base: ; current number base
  dw 0x000A

; --------------------------------------------------------------
  ;: rp0 ( -- a )

  header rp0_,"rp0",0

  ld hl,rp0
  jp push_hl
rp0: ; initial value of the return stack pointer
  dw return_stack_bottom

; --------------------------------------------------------------
  ;: rp@ ( -- a )

  header rp_fetch_,"rp@",0

  ld ($+5),sp
  ld hl,0
  jp push_hl

; --------------------------------------------------------------
  ;: rp! ( a -- )

  header rp_store_,"rp!",0

  jp pop_hl
  di
  ld sp,hl
  ei
  ret

; --------------------------------------------------------------
  ;: sp0 ( -- a )

  header sp0_,"sp0",0

sp0: equ $+1 ; initial value of the data stack pointer
  ld hl,data_stack_bottom
  jp push_hl

; --------------------------------------------------------------
  ;: sp@ ( -- a )

  header sp_fetch_,"sp@",0

if data_stack_method = ix_dsm

  push ix
  pop hl

else

dsp: equ $+1 ; data stack pointer
  ld hl,data_stack_bottom

endif

  jp push_hl

; --------------------------------------------------------------
  ;: sp! ( a -- )

  header sp_store_,"sp!",0

  call pop_hl
  if data_stack_method = ix_dsm
    ; XXX TODO -- improve with direct fetch of _a_
    push hl
    pop ix
  else
    ld (dsp),hl
  endif
  ret

; --------------------------------------------------------------
  ;: decimal ( -- )

  header decimal_,"decimal",0

  ld a,0x0a
  ld (base),a
  ret

; --------------------------------------------------------------
  ;: hex ( -- )

  header hex_,"hex",0

  ld a,0x10
  ld (base),a
  ret

; --------------------------------------------------------------
  ;: c, ( c -- )

  header c_comma_,"c,",0

  call pop_hl
  ld a,l
  ld hl,(dp)
  ld (hl),a
  inc hl
  ld (dp),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  ;: , ( x -- )

  header comma_,",",0

  call pop_hl
  ld de,(dp)
  ex de,hl
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (dp),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  ;: allot ( n -- )

  header allot_,"allot",0

  call pop_hl
  ld de,(dp)
  add hl,de
  ld (dp),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  ;: ! ( x a -- )

  header store_,"!",0

  call pop_hl_de
  ld (hl),e
  inc hl
  ld (hl),d
  ret

; --------------------------------------------------------------
  ;: c! ( c a -- )

  header c_store_,"c!",0

  call pop_hl_de
  ld (hl),e
  ret

; --------------------------------------------------------------
  ;: @ ( a -- )

  header fetch_,"@",0

  call pop_hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  jp push_hl ; XXX TODO -- push_de ?

; --------------------------------------------------------------
  ;: c@ ( ca -- )

  header c_fetch_,"c@",0

  call pop_hl
  ld l,(hl)
  ld h,0x00
  jp push_hl

; --------------------------------------------------------------
  ;: on ( a -- ) comus ; {{{2

  header on_,"on",0

  call pop_hl
  ld (hl),true
  ret

; --------------------------------------------------------------
  ;: off ( a -- ) comus ; {{{2

  header off_,"off",0

  call pop_hl
  ld (hl),false
  ret

; --------------------------------------------------------------
  ;: dp ( -- a ) fig ; {{{2
  ;:
  ;: Return the address of the dictionary pointer variable, which contains the
  ;: next free memory location above the dictionary. The value may be read by
  ;: `here` and altered by `allot`.

  header dp_,"dp",0

dp: equ $+1
  ld hl,end_of_code
  jp push_hl

; --------------------------------------------------------------
  ;: here ( -- a ) fig,79,83,94 ; {{{2
  ;:
  ;: Return the content of `dp`, the address of the next available memory
  ;: location above the dictionary.

  header here_,"here",0

  ld hl,(dp)
  jp push_hl

; --------------------------------------------------------------
  ;: latest ( -- nfa ) fig,af,gforth ; {{{2
  ;:
  ;: Return the name field address of the last word defined in the `current`
  ;: vocabulary.

  ; XXX TODO -- `current` is not implemented yet

  header latest_,"latest",0

latest: equ $+1
  ld hl,current_latest ; nfa of the latest Forth word in the dictionary
  jp push_hl

; --------------------------------------------------------------
  ;: ;code ( colon-sys -- ) ; XXX TODO -- stack ; {{{2

  header semicolon_code_,";code",immediate

  ; XXX TODO adapt, test

  call pop_hl
  ld a,colon_structure_id
  cp l
  jr z,l56cch
  ld (pairs_fvar),a
  call push_hl
  jp semicolon.end
l56cch:
  xor a
  ld (pairs_fvar),a
semicolon.end:
  call left_bracket_
  jp save_dictionary_pointers

; --------------------------------------------------------------
  ;: code: ( -- )
  ;:
  ;: XXX TODO adapt, test

  header code_colon_,"code:",immediate

  call right_bracket_
  ld a,(pairs_fvar)
  and a
  ret nz
  ld l,colon_structure_id
  jp push_hl

; --------------------------------------------------------------
  ;: in ( a -- c ) zx ; {{{2

  header in_,"in",0

  call pop_hl
  ld b,h
  ld c,l
  in a,(c)
  ld l,a
  ld h,0x00
  jp push_hl

; --------------------------------------------------------------
  ;: out ( a c -- ) zx ; {{{2

  header out_,"out",0

  call pop_hl_de
  ld b,h
  ld c,l
  out (c),e
  ret

; --------------------------------------------------------------
  ;: page ( -- ) 83,94 ; {{{2
  ;:
  ;: On a terminal, clear the screen and resets the cursor position to the
  ;: upper left corner.  On a printer perform a form feed.

  header page_,"page",0

linked_stream: equ $+1 ; XXX TODO make it a variable
  ld a,0x00
  cp 0x03 ; printing?
  jp nz,cls_
  ; printing
  ld a,form_feed_char
  jp print_a

; --------------------------------------------------------------
  ;: do ( -- do-sys ) ; XXX TODO -- stack ; {{{2

  header do_,"do",immediate+compile_only

  ld de,do_do
  call compile_call_de
  ; hl = dp
  call push_hl ; save the address `loop` must jump to
  ld l,do_structure_id
  jp push_hl ; XXX TODO -- push_a?

  ; XXX TODO -- factor to a word (`(do)`?)
do_do:
  pop bc
  call pop_hl_de
  push hl
  push de
  push bc
  ret

l574fh:
  pop hl
  pop de
  pop bc
  push hl
  push bc
  ld a,0x80
  xor d
  ld d,a
  call pop_hl
  ld b,h
  ld c,l
  pop hl
  add hl,bc
  rl b
  push af
  ld b,h
  ld c,l
  ld a,0x80
  xor h
  ld h,a
  pop af
  jr c,l5772h
  and a
  sbc hl,de
  jr c,l5779h
  jp l5785h

l5772h:
  and a
  sbc hl,de
  jr c,l5785h
  jr z,l5785h

l5779h:
  pop hl
  push bc
  ld a,0x80
  xor d
  ld d,a
  push de
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ret

l5785h:
  pop hl
  inc hl
  inc hl
  jp (hl)

l5789h:
  pop de
  pop hl
  pop bc
  inc bc
  push hl
  and a
  sbc hl,bc
  jr z,l62e0h
  pop hl
  push bc
  push hl
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ret

l62e0h:
  pop bc
  ex de,hl
  inc hl
  inc hl
  jp (hl)

; --------------------------------------------------------------
  ;: +loop ( do-sys - ) ; XXX TODO -- stack

  header plus_loop_,"+loop",immediate+compile_only

  ld a,do_structure_id
  call structured
  ld de,l574fh
  call compile_call_de
  ; hl = dp
  jp sub_57a3h

sub_57a3h:
  call pop_hl
  ld b,h
  ld c,l
  ld hl,(dp)
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  ;: loop ( do-sys -- ) ; XXX TODO -- stack ; {{{2

  header loop_,"loop",immediate+compile_only

  ld a,do_structure_id
  call structured
  ld de,l5789h
  call compile_call_de
  ; hl = dp
  jp sub_57a3h

; --------------------------------------------------------------
  ;: j ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 ) hist,94 ; {{{2
  ;:
  ;: Return a copy of the index of the next outer loop.  May only
  ;: be used within a nested `do`-`loop` or `do`-`+loop` structure.

  header j_,"j",0

  ld hl,0x000A
  add hl,sp
  ld a,(hl)
  inc hl
  ld l,(hl)
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  ;: i ( -- n|u ) ( R: loop-sys -- loop-sys ) hist,94 ; {{{2
  ;:
  ;: Return a copy of the current (innermost) loop index. May only
  ;: be used within a nested `do`-`loop` or `do`-`+loop` structure.

  header i_,"i",0

  ld hl,0x0004
  add hl,sp
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  jp push_hl

; --------------------------------------------------------------
  ;: link ( n -- ) sf ; {{{2
  ;: XXX TODO adapt

  header link_,"link",0

  call pop_hl
  ld a,l
link.a:
;;  cp 0x03
;;  jr nz,link.other_than_3
;;  ; stream = 3
;; XXX OLD:
;;  set 7,(iy+0x00)
;;  jp link.do
;;  ; link to channel p
;;link.other_than_3:
;;  ; stream <> 3
;; XXX OLD:
;;  res 7,(iy+0x00)
;;  xor a
;; link.do:

  ld (linked_stream),a ; XXX NEW
  jp rom_chan_open

; --------------------------------------------------------------
  ;: home ( -- ) comus,cf ; {{{2
  ;:
  ;: Make the next character displayed will appear in column 0, row 0 of the
  ;: user output device, the upper left corner.

  header home_,"home",0

  ld a,at_char
  call print_a
  xor a
  call print_a
  xor a
  jp print_a

; --------------------------------------------------------------
  ;: at-xy ( u1 u2 -- ) 94,cf ; {{{2
  ;:
  ;: Make the next character displayed will appear in column u1, row u2 of the
  ;: user output device, the upper left corner of which is column zero, row
  ;: zero.
  ;: Note: In Couplement Forth, the upper bytes of the parameters are ignored.

  header at_xy_,"at-xy",0

  ld a,at_char
  call print_a
  call pop_hl_de
  push de
  ld a,l
  call print_a
  pop de
  ld a,e
  jp print_a

; --------------------------------------------------------------
  ;: border ( u -- ) zx ; {{{2

  header border_,"border",0

  ; XXX TODO adapt
  call pop_hl
  ld a,l
border.a:
  out (0xfe),a
  ret

; --------------------------------------------------------------
  ;: beep ( u1 u2 -- ) zx ; {{{2

  header beep_,"beep",0

  ; XXX TODO
  ret

; --------------------------------------------------------------
  ;: ." ( "ccc<quote>" -- )

  header dot_quote_,'."',immediate+compile_only

  ; XXX TODO -- Rewrite with a porsing word.

  ld de,l582bh
  call compile_call_de
  ; hl = dp
  ld de,(ip_fvar)
  inc de
l5812h:
  inc de
  ld a,(de)
  cp 0x22
  jr z,l5820h
  cp 0x0d
  jr z,l5820h
  ld (hl),a
  inc hl
  jp l5812h
l5820h:
  ld (hl),0xff
  inc hl
  ld (dp),hl
  ld (ip_fvar),de
  ret

l582bh:
  pop hl
l582ch:
  ld a,(hl)
  cp 0xff
  jr z,l5837h
  call print_a
  inc hl
  jp l582ch
l5837h:
  inc hl
  jp (hl)

; --------------------------------------------------------------
  ;: * ( n1 n2 -- n3 )

  header star_,"*",0

  call u_mult_ ; XXX TODO -- `u*`?
  jp pop_hl

; --------------------------------------------------------------
  ;: type ( ca len -- )

  header type_,"type",0

  call pop_hl_de
  ex de,hl
  ld b,d
  ld c,e
  jp print_bc_chars_at_hl

; --------------------------------------------------------------
  ;: bye ( -- )

  header bye_,"bye",0

saved_basic_sp: equ $+1 ; Sinclair BASIC's stack pointer
  ld hl,0
  ld sp,hl
  rst 0x08     ; error
  db 0xff      ; 0: "OK"

; --------------------------------------------------------------
  ;: return ( n -- )
  ;:
  ;: Return to BASIC with return code _n_.
  ;: The return code is used as line number for disk operations.

  header return_,"return",0

  call pop_hl
return.hl:
  ld b,h
  ld c,l
return.bc:
  ld sp,(saved_basic_sp)
  ret

return.a:
  ;: Return to BASIC with register A as return code.
  ld b,0
  ld c,a
  jr return.bc

; --------------------------------------------------------------
  ;: dir ( -- )

  header dir_,"dir",0

  ld a,0x03 ; dir id
  jp return.a

; --------------------------------------------------------------
  ;: = ( n1 n2 -- f )

  header equals_,"=",0

  ; XXX TODO -- write "<>"
  call pop_hl_de
  if size_optimization
    call compare_de_hl_unsigned:
    jp z,true_
    jp false_
  else
    ld a,l  ; 09 T
    cp e    ; 04 T
    jp nz,false_
    ld a,h  ; 09 T
    cp d    ; 09 T
    jp nz,false_
    jp true_
  endif

; --------------------------------------------------------------
  ;: <> ( n1 n2 -- f )

  header not_equals_,"<>",0

  call pop_hl_de
  if size_optimization
    call compare_de_hl_unsigned:
    jp z,false_
    jp true_
  else
    ; XXX TODO test it
    ld a,l  ; 09 T
    cp e    ; 04 T
    jp nz,true_
    ld a,h  ; 09 T
    cp d    ; 09 T
    jp nz,true_
    jp false_
  endif

; --------------------------------------------------------------
  ;: / ( n1 n2 -- n3 )

  header slash_,"/",0

  call slash_mod_
  call swap_
  jp pop_hl

; --------------------------------------------------------------
  ;: mod ( n1 n2 -- n3 )

  header mod_,"mod",0

  call slash_mod_
  jp pop_hl

; --------------------------------------------------------------
  ;: begin ( -- begin-sys ) ; XXX TODO -- stack ; {{{2

  header begin_,"begin",immediate+compile_only

  ld hl,(dp)
  call push_hl
  ld l,begin_structure_id
  jp push_hl

; --------------------------------------------------------------
  ;: until ( begin-sys -- )

  header until_,"until",immediate+compile_only

  ld a,begin_structure_id
  call structured
  ld de,zero_branch_
  call compile_call_de
  ; hl = dp
  jp sub_57a3h

; --------------------------------------------------------------
  ;: < ( n1 n2 -- f )

  header less_,"<",0

  call pop_hl_de
  ex de,hl
  ld a,d
  xor h
  bit 7,a
  jr nz,l5a4fh
  sbc hl,de
l5a4fh:
  bit 7,h
  jp z,false_
  jp true_

; --------------------------------------------------------------
  ;: > ( n1 n2 -- f )

  header greater_,">",0

  ; XXX TODO -- direct version, no swap
  call swap_
  jp less_

; --------------------------------------------------------------
  ;: u< ( n1 n2 -- f )

  header u_less_,"u<",0 ; XXX TMP name

  call pop_hl_de
  ex de,hl
  call compare_de_hl_unsigned
  jp c,true_
  jp false_

compare_de_hl_unsigned:
  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de
  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

; --------------------------------------------------------------
  ;: rdrop ( -- ) ( R: x -- ) ; {{{2

  header r_drop_,"rdrop",0

  ; XXX TODO test (old code: pop hl / ret)
  pop hl
  pop de
  jp (hl)

; --------------------------------------------------------------
  ;: r@ ( -- x ) ( R: x --  ) ; {{{2

  header r_fetch_,"r@",0

  pop hl
  push hl
  jp push_hl

; --------------------------------------------------------------
  ;: r> ( -- x ) ( R: x -- ) ; {{{2

  header r_from_,"r>",0

  pop bc
  pop hl
  push bc
  jp push_hl

; --------------------------------------------------------------
  ;: >r ( x -- ) ( R: -- x ) ; {{{2

  header to_r_,">r",0

  call pop_hl
  pop bc
  push hl
  push bc
  ret
  ; XXX TODO -- future optimization:
;  call pop_de
;  pop hl
;  push de
;  jp (hl)

; --------------------------------------------------------------
  ;: key? ( -- f )

  header key_question_,"key?",0

  ; XXX TODO

  jp true_ ; XXX TMP

  if 0

  ld a,(sys_last_k)
  ld (previous_key),a
key_question.1
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key?
  jp z,key.1
  ld l,a ; save the key
  xor a
  ld (sys_last_k),a ; delete the last key
  ld h,0
  jp push_hl

  ; XXX TODO see the code of Couplement Forth

  endif

; --------------------------------------------------------------
  ;: key ( -- c )

  header key_,"key",0

  ; XXX TODO call `key?`
  ld a,(sys_last_k)
  ld (previous_key),a
key_.wait
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key?
  jp z,key_.wait
  ld l,a ; save the key
  xor a
  ld (sys_last_k),a ; delete the last key
  ld h,0
  jp push_hl

; --------------------------------------------------------------
  ;: over ( x1 x2 -- x1 x2 x1 )

  header over_,"over",0

  call pop_hl_de
  call push_de_hl
  ex de,hl
  jp push_hl

; --------------------------------------------------------------
  ;: rot ( x1 x2 x3 -- x2 x3 x1 )

  header rot_,"rot",0

  call pop_hl_de
  ld b,h
  ld c,l
  call pop_hl
  push hl
  ld h,b
  ld l,c
  call push_de_hl
  pop hl
  jp push_hl

; --------------------------------------------------------------
  ;: 2dup ( x1 x2 -- x1 x2 x1 x2 )

  header two_dup_,"2dup",0

  call pop_hl_de
  call push_de_hl
  jp push_de_hl

; --------------------------------------------------------------
  ;: pad ( -- a )
  ;:
  ;: Places the address of the pad on the top of the stack. See the definition
  ;: of INPUT under NUMBER.

  header pad_,"pad",0

pad_address: equ $+1
  ld hl,pad_start ; XXX TODO -- rename
  jp push_hl

; --------------------------------------------------------------
  ;: tib ( -- a )

  header tib_,"tib",0

tib_address: equ $+1 ; start address of the Terminal Input Buffer
  ld hl,tib_start ; XXX TODO -- understand why originally it's tib_end; tib_start works too, if etib_fvar is set to tib_start
  jp push_hl

; XXX TODO
;to_in_lfa:
;  dw pad_name
;to_in_nfa:
;  db 0x03
;to_in_name:
;  db ">in"
;to_in_:
;  ld hl,to_in
;  jp push_hl
;to_in:
;  dw 0x0000 ; character offset within the input stream

; --------------------------------------------------------------
  ;: query ( -- )
  ;:
  ;: Clear the input buffer and accept character input until RETURN is
  ;: pressed.  It can be edited in the normal way.

  header query_,"query",0

  ; XXX TODO -- simplify, standardize
  ld hl,(tib_address)
  push hl
  ld hl,(pad_address)
  inc hl
  ld (tib_address),hl
  call keyboard_input
  pop hl
  ld (tib_address),hl
  ret

; --------------------------------------------------------------
  ;: retype ( -- )
  ;:
  ;: This is similar to QUERY but does not clear the input buffer enabling the
  ;: text to be edited. Move the text into PAD starting at the second address
  ;: of PAD before calling RETYPE.

  header retype_,"retype",0

  ; XXX TODO -- simplify, standardize
  ld hl,(tib_address)
  push hl
  ld hl,(pad_address)
  inc hl
  ld (tib_address),hl
  call keyboard_input.next_key
  pop hl
  ld (tib_address),hl
  ret

; --------------------------------------------------------------
  ;: -cursor ( n -- ) ; XXX NEW ; {{{2
  ;:
  ;: Delete the cursor.

  header minus_cursor_,"-cursor",0

  call space_
  call c_lit_
  db left_char
  jp emit_

; --------------------------------------------------------------
  ;: backspaces ( +n -- )
  ;:
  ;: Delete +n chars at the left of the cursor.

  header backspaces_,"backspaces",0

  call c_lit_
  db left_char
  call dup_
  call emit_
  call space_
  call emit_
  call one_minus_
  call dup_
  call zero_equals_ ; XXX TODO --
  call zero_branch_ ; XXX TODO -- improve with `?branch`
  dw backspaces_
  jp drop_

; --------------------------------------------------------------
  ;: (accept-control-char) ( ca len len2 c -- ca len len2' )

  header paren_accept_control_char_,"(accept-control-char)",0

  border 2 ; XXX INFORMER
  ; check the delete key
  call dup_
  call c_lit_
  db delete_char
  call equals_ ; delete?
  call zero_branch_
  dw paren_accept_control_char.edit
  ; delete the last char
  call drop_ ; c
  call dup_ ; something to delete?
  call zero_branch_
  dw paren_accept_control_char.end
  ; do it
  call minus_cursor_
  call one_minus_
  call one_
  jp backspaces_

paren_accept_control_char.edit:
  ; check the edit key
  call c_lit_
  db edit_char
  call equals_ ; edit?
  call zero_branch_
  dw paren_accept_control_char.end
  ; delete the whole input
  call dup_ ; something to delete?
  call zero_branch_
  dw paren_accept_control_char.end
  ; do it
  call minus_cursor_
  call zero_
  call swap_
  call backspaces_

paren_accept_control_char.end:
  ret

; --------------------------------------------------------------
  ;: (accept-ascii-char) ( ca len len2 c -- ca len len2' )

  header paren_accept_ascii_char_,"(accept-ascii-char)",0

  border 4 ; XXX INFORMER
  call to_r_
  call two_dup_
  call minus_
  call r_from_
  call swap_ ; space left
  call zero_branch_
  dw paren_accept_ascii_char.no

  ; there's space left for the char
  call dup_
  call emit_
  call over_
  call c_lit_
  db 4
  call pick_
  call plus_
  call c_store_
  jp one_plus_

paren_accept_ascii_char.no:
  ; no space left for the char
  jp drop_

; --------------------------------------------------------------
  ;: (accept-key) ( ca len len2 c -- ca len len2' )

  header paren_accept_key_,"(accept-key)",0

  call dup_
  call bl_
  call c_lit_
  db 127
  if false
    ; XXX FIXME
    call within_ ; ASCII?
  else
    call over_
    call minus_
    call to_r_
    call minus_
    call r_from_
    call u_less_
  endif
  call zero_branch_
  dw paren_accept_control_char_ ; not ASCII
  jp paren_accept_ascii_char_ ; ASCII

; --------------------------------------------------------------
  ;: (accept) ( ca len -- len2 )

  header paren_accept_,"(accept)",0

  call zero_ ; len2
paren_accept.begin:
  call c_lit_
  db 143 ; XXX TMP cursor
  call emit_
  call c_lit_
  db bs_char
  call emit_
  call key_
  call dup_
  call c_lit_
  db cr_char
  call equals_  ; return?
  call zero_branch_
  dw paren_accept_key_ ; no
  ; the return key was pressed
  call minus_cursor_
  call space_
  call drop_
  call nip_
  jp nip_

; --------------------------------------------------------------
  ;: accept ( ca +n1 -- +n2 )

  header accept_,"accept",0

  jp paren_accept_

; --------------------------------------------------------------
  ;: word ( char "<chars>ccc<char>" -- c-addr )
  ;:
  ;: XXX TODO -- edit the following ANS description:
  ;:
  ;: Skip leading delimiters.  Parse characters ccc delimited by char.  An
  ;: ambiguous condition exists if the length of the parsed string is greater
  ;: than the implementation-defined length of a counted string.
  ;:
  ;: c-addr is the address of a transient region containing the parsed word as
  ;: a counted string.  If the parse area was empty or contained no characters
  ;: other than the delimiter, the resulting string has a zero length.  A
  ;: space, not included in the length, follows the string.  A program may
  ;: replace characters within the string.
  ;:
  ;: Note: The requirement to follow the string with a space is obsolescent and
  ;: is included as a concession to existing programs that use CONVERT.  A
  ;: program shall not depend on the existence of the space.

  header word_,"word",0

  ; XXX TODO -- test; it has been rewritten after ANS
  call pop_hl
  ld a,l
  ld hl,(ip_fvar)
word.skip_leading_delimiter:
  inc hl
  cp (hl)
  jp z,word.skip_leading_delimiter
  ; hl=address of the first valid char to parse
  push hl
  ld bc,0x0000 ; char count
word.parse:
  inc c
  inc hl
  cp (hl)
  jr nz,word.parse
  ; trailing delimiter found
  ; bc = length of the parsed text (0-255)
  ld hl,(pad_address) ; destination
  ld a,c
  ld (hl),a
  inc hl
  pop de ; origin
  ex de,hl
  ldir ; move the text
  ld (ip_fvar),hl
  ld hl,(pad_address)
  jp push_hl

; --------------------------------------------------------------
  ;: if ( -- if-sys ) ; XXX TODO -- stack ; {{{2

  header if_,"if",immediate+compile_only

  ld de,zero_branch_
  call compile_call_de
  ; hl = dp
  call push_hl ; save the address of the jump address
  inc hl
  inc hl
  ld (dp),hl ; skip it
  ld l,if_structure_id
  jp push_hl ; XXX TODO -- push_a?

; --------------------------------------------------------------
  ;: else ( if-sys -- if-sys ) ; XXX TODO -- stack ; {{{2

  header else_,"else",immediate+compile_only

  ld a,if_structure_id
  call structured
  ld de,branch_
  call compile_call_de
  ; hl = dp
  push hl
  inc hl
  inc hl
  ld (dp),hl
  call pop_hl
  ld bc,(dp)
  ld (hl),c
  inc hl
  ld (hl),b
  pop hl
  call push_hl
  ld l,if_structure_id
  jp push_hl

; --------------------------------------------------------------
  ;: then ( if-sys -- ) ; XXX TODO -- stack ; {{{2

  header then_,"then",immediate+compile_only

  ld a,if_structure_id
  call structured
  call pop_hl
  ld bc,(dp)
  ld (hl),c
  inc hl
  ld (hl),b
  ret

; --------------------------------------------------------------
  ;: <builds ( "name" -- ) ; XXX TODO -- stack ; {{{2

  header builds_,"<builds",compile_only

  ; XXX TODO -- remove, adapt
  ld de,create_header
  call compile_call_de
  ; hl = dp
  ld (hl),0x11
  inc hl
  call push_hl
  inc hl
  inc hl
  ld (dp),hl
  ld de,compile_call_de
  call compile_call_de
  ; hl = dp
  ld (hl),0x36
  inc hl
  ld (hl),0xc9  ; Z80 "ret"
  inc hl
  ld (hl),0x23
  inc hl
  ld (hl),0x22
  inc hl
  ld bc,dp
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ld l,builds_structure_id
  jp push_hl

; --------------------------------------------------------------
  ;: does> ( -- ) ; XXX TODO -- stack ; {{{2

  header does_,"does>",immediate+compile_only

  ld a,builds_structure_id
  call structured
  ld hl,(dp)
  ld (hl),0xc9  ; Z80 "ret"
  inc hl
  ld (dp),hl
  ld d,h
  ld e,l
  call pop_hl
  ld (hl),e
  inc hl
  ld (hl),d
  ld hl,(dp)
  ld (hl),0xe1  ; Z80 "pop hl"
  inc hl
  ld (hl),0xe5  ; Z80 "push hl"
  inc hl
  ld (hl),0x23  ; Z80 "inc hl"
  inc hl
  ld (hl),0xcd  ; Z80 "call...
  inc hl
  ld bc,push_hl
  ld (hl),c
  inc hl
  ld (hl),b     ; Z80 ...address"
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  ;: while ( begin-sys -- begin-sys ) ; XXX TODO -- stack ; {{{2

  header while_,"while",immediate+compile_only

  ld a,begin_structure_id
  call structured
  ld de,zero_branch_
  call compile_call_de
  ; hl = dp
  call push_hl
  inc hl
  inc hl
  ld (dp),hl
  ld l,begin_structure_id
  jp push_hl

; --------------------------------------------------------------
  ;: repeat ( begin-sys -- ) ; XXX TODO -- stack ; {{{2

  header repeat_,"repeat",immediate+compile_only

  ld a,begin_structure_id
  call structured
  ld de,branch_
  call compile_call_de
  ; hl = dp
  push hl
  inc hl
  inc hl
  ld (dp),hl
  ld b,h
  ld c,l
  call pop_hl
  ld (hl),c
  inc hl
  ld (hl),b
  call pop_hl
  ld b,h
  ld c,l
  pop hl
  ld (hl),c
  inc hl
  ld (hl),b
  ret

; --------------------------------------------------------------
  ;: variable ( -- a )

  header variable_,"variable",0

  call create_header
  ld de,do_variable
  call compile_call_de
  ; hl = dp
  inc hl
  inc hl ; point to the address after the value
  ld (dp),hl
  jp save_dictionary_pointers

; XXX TODO create word `(variable)` or `do_variable` and call to its cfa
do_variable:
  pop hl ; get the return address
  jp push_hl

; --------------------------------------------------------------
  ;: constant ( -- x )

  header constant_,"constant",0

  call create_header
  ld de,do_constant
  call compile_call_de
  ; hl = dp
  call pop_hl
  ; XXX TODO two next lines could be omited if only pop_de could be used instead of pop_hl above:
  ex de,hl ;
  ld hl,(dp)
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (dp),hl
  jp save_dictionary_pointers

; XXX TODO create word `(constant)` or `do_constant` and call to its cfa
do_constant:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  jp push_hl

; --------------------------------------------------------------
  ;: . ( n -- )

  header dot_,".",0

  ; XXX TODO -- 2020-05-27: make standard, factor, rewrite

  call pop_hl
  bit 7,h ; negative?
  jr z,dot_code_field.do
  ; negative number
  ex de,hl
  ld hl,0x0000
  sbc hl,de
  ld a,"-"
  call print_a
dot_code_field.do:
  call push_hl
  jp u_dot_

; --------------------------------------------------------------
  ;: cmove ( ca1 ca2 len -- )

  header cmove_,"cmove",0

  call pop_hl
  ld a,h
  or l ; something to move?
  jr z,cmove.end ; nothing
  ld b,h
  ld c,l
  call pop_hl_de
  ex de,hl
  ldir
  ret
cmove.end:
  jp pop_hl_de

; --------------------------------------------------------------
  ;: and ( x1 x2 -- f )

  header and_,"and",0

  call pop_hl_de
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  ;: or ( x1 x2 -- f )

  header or_,"or",0

  call pop_hl_de
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  ;: xor ( x1 x2 -- f )

  header xor_,"xor",0

  call pop_hl_de
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  ;: not ( x1 -- x2 )

  header not_,"not",0

  ; XXX TODO --- investigate, rename "0=" or "invert"
  call pop_hl
  xor a
  cp l
  inc hl
  jr z,l5d4bh
  ld l,0x00
l5d4bh:
  ld h,0x00
  jp push_hl

; --------------------------------------------------------------
  ;: false ( -- false )

  header false_,"false",0

  ld hl,0
  jp push_hl

; --------------------------------------------------------------
  ;: true ( -- true )

  header true_,"true",0

  ld hl,-1
  jp push_hl

; --------------------------------------------------------------
  ;: 0 ( -- 0 )

  header zero_,"0",0

  ld hl,0
  jp push_hl

; --------------------------------------------------------------
  ;: 1 ( -- 1 )

  header one_,"1",0

  ld hl,1
  jp push_hl

; --------------------------------------------------------------
  ;: bl ( -- c ) 94 ; {{{2

  header bl_,"bl",0

  ld hl,space_char
  jp push_hl

; --------------------------------------------------------------
  ;: count ( a -- a' u ) 94 ; {{{2

  header count_,"count",0

  call pop_hl
  ld a,(hl)
  inc hl
  call push_hl
  ld h,0
  ld l,a
  jp push_hl

; --------------------------------------------------------------
  ;: find ( "name" -- cfa ) ; ; {{{2

  header find_,"find",0

  ; XXX TODO -- rewrite according to ANS; now it simply skips leading blanks!
  ; XXX TODO -- move this code to `(find)`
  ld de,(ip_fvar)
find.skip_blank:
  inc de
  ld a,(de)
  cp space_char
  jp z,find.skip_blank
  cp cr_char
  jp z,find.skip_blank
  ld (ip_fvar),de

  ld b,10 ; XXX TMP --- debugging
  check "Name in find:"
  check.string.de_b

  jp paren_find_

; --------------------------------------------------------------
  ;: (abort) ( i*x -- ) ( R: j*x -- ) comus ; {{{2
  ;:
  ;: Empty the data stack and perform the function of `quit`, which includes
  ;: emptying the return stack, without displaying a message.

  header paren_abort_,"(abort)",0

  ; XXX TODO -- test, confirm
  call init_data_stack
  jp quit_

; --------------------------------------------------------------
  ;: abort ( i*x -- ) ( R: j*x -- ) 94 ; {{{2
  ;:
  ;: Empty the data stack and perform the function of QUIT, which includes
  ;: emptying the return stack, without displaying a message.

  header abort_,"abort",0

  ; XXX NEW -- 2013-02-02
  ; XXX TODO -- test, confirm
  ; XXX TODO -- improve with the exception extension set
  jp paren_abort_

; --------------------------------------------------------------
  ;: cold ( -- ) fig,comus,gforth ; {{{2
  ;:
  ;: The cold start procedure.  Adjust the dictionary pointer to the minimum
  ;: standard and restart via `abort`.  May be called from terminal to remove
  ;: the application program and restart.

  header cold_,"cold",0

cold_latest: equ $+1 ; nfa of the last Forth word in dictionary at cold start
  ld hl,current_latest
  ld (latest),hl
cold_dp: equ $+1 ; next vacant address in dictionary at cold start
  ld hl,end_of_code
  ld (dp),hl
  ld (fence),hl
  call save_dictionary_pointers
  call left_bracket_
  call page_
  call bootmessage_
  ; XXX NOTE -- 2013-02-02 quit_ changed to abort_, after FIG-Forth.
  jp abort_

; --------------------------------------------------------------
  ;: fence ( -- a ) fig ; {{{2
  ;:
  ;: Return an address which contains the address below which `forget` will not operate.

  header fence_,"fence",0

  ld hl,fence
  jp push_hl
fence:
  dw end_of_code ; address below which `forget` will not operate.

; --------------------------------------------------------------
  ;: u/mod ( -- ) ; XXX TODO -- stack ; {{{2

  header u_slash_mod_,"u/mod",0

  call pop_hl
  ld b,h
  ld c,l
  call pop_hl_de
  ld a,l
  sub c
  ld a,h
  sbc a,b
  jr c,l5dc3h
  ld hl,0xffff
  ld de,0xffff
  jp l5de3h
l5dc3h:
  ld a,0x10
l5dc5h:
  add hl,hl
  rla
  ex de,hl
  add hl,hl
  jr nc,l5dcdh
  inc de
  and a
l5dcdh:
  ex de,hl
  rra
  push af
  jr nc,l5dd7h
  and l
  sbc hl,bc
  jp l5ddeh
l5dd7h:
  and a
  sbc hl,bc
  jr nc,l5ddeh
  add hl,bc
  dec de
l5ddeh:
  inc de
  pop af
  dec a
  jr nz,l5dc5h
l5de3h:
  ex de,hl
  jp push_de_hl

; --------------------------------------------------------------
  ;: <# ( -- ) ; XXX TODO -- stack ; {{{2

  header less_number_sign_,"<#",0

  call pad_
  call pop_hl
  ld (hlds_fvar),hl
  ret

; --------------------------------------------------------------
  ;: #> ( -- ) ; XXX TODO -- stack ; {{{2

  header number_sign_greater_,"#>",0

  call pop_hl_de
  ld hl,(hlds_fvar)
  call push_hl
  call pad_
  call over_
  jp minus_

; --------------------------------------------------------------
  ;: # ( -- ) ; XXX TODO -- stack ; {{{2

  header number_sign_,"#",0

  ; XXX TODO -- avoid fetching base every time `#s` calls `#`:
  ld hl,(base)
  call push_hl
  call sub_5fc2h
  call rot_
  ld hl,0x0009
  call push_hl
  call over_
  call less_
  call zero_branch_
  dw branch_5e39
  ld hl,0x0007
  call push_hl
  call plus_
branch_5e39:
  ld hl,0x0030
  call push_hl
  call plus_
  jp hold_

sub_5fc2h:
  call r_from_
  ld hl,0x0000
  call push_hl
  call to_r_
  call dup_
  call r_from_
  call u_slash_mod_
  call to_r_
  call swap_
  call r_from_
  call u_slash_mod_
  call to_r_
  ret

; --------------------------------------------------------------
  ;: #s ( -- ) ; XXX TODO -- stack ; {{{2

  header number_sign_s_,"#s",0

  call number_sign_
  call over_ ; XXX TODO -- over over -> 2dup
  call over_
  call or_
  call question_branch_
  dw number_sign_s_
  ret

; --------------------------------------------------------------
  ;: d. ( d -- )

  header d_dot_,"d.",0

  ; XXX FIXME -- 2020-05-27

  call less_number_sign_
  call number_sign_s_
  call number_sign_greater_
  call type_
  jp space_

; --------------------------------------------------------------
  ;: hold ( c -- )

  header hold_,"hold",0

  ld hl,(hlds_fvar)
  dec hl
  ld (hlds_fvar),hl
  call pop_hl
  ld a,l
  ld hl,(hlds_fvar)
  ld (hl),a
  ret

; --------------------------------------------------------------
  ;: sign ( n d -- ) ; XXX TODO -- stack ; {{{2
  ;: sign ( n -- ) ; XXX TODO -- standard

  header sign_,"sign",0

  call rot_ ; XXX TODO -- this is not standard
  call zero_less_
  call zero_branch_ ; XXX TODO -- use `0exit`
  dw sign_.end
  call c_lit_
  db "-"
  call hold_
sign_.end:
  ret

; --------------------------------------------------------------
  ;: 0= ( n -- f )

  header zero_equals_,"0=",0

  call pop_hl
  ld a,l
  or h
  ld hl,0x0000
  jp nz,push_hl
  dec hl
  jp push_hl

; --------------------------------------------------------------
  ;: 0< ( n -- f )

  header zero_less_,"0<",0

  call pop_hl
  bit 7,h
  ld hl,0x0000
  jp z,push_hl
  dec hl
  jp push_hl

; --------------------------------------------------------------
  ;: forget ( "name" -- )

  header forget_,"forget",0

  call find_
  ex de,hl
  call pop_hl
  ld a,h
  or l
  check "undefined 4"
  jp z,undefined_word_error
  ld hl,(fence)
  sbc hl,de
  jp nc,inside_fence_error
  ex de,hl
  dec hl
  ld b,(hl)
  dec hl
  ld c,(hl)
  ld (latest),bc
  ld (dp),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  ;: error ( n -- )

  header error_,"error",0

  ; XXX TODO --- rename "throw"
  call pop_hl
  ld a,l
  jp error_a

; --------------------------------------------------------------
  ;: ( ( "text"<closing-paren> -- )

  header paren_,"(",immediate

  ld hl,(ip_fvar)
paren_.next:
  inc hl
  ld a,')'
  cp (hl)
  jr nz,paren_.next
  ld (ip_fvar),hl
  ret

; --------------------------------------------------------------
  ;: pick ( x#u...x#1 x#0 u -- x#u...x#1 x#0 x#u )

  header pick_,"pick",0

  call pop_hl
  ld a,h
  or l
  ret z
  ld e,l
  dec e
  rl e
  if data_stack_method = ix_dsm
    push ix
    pop hl
  else
    ld hl,(dsp)
  endif
  ld d,0x00
  add hl,de
  ld c,(hl)
  inc hl
  ld b,(hl)
  ld h,b
  ld l,c
  jp push_hl

; --------------------------------------------------------------
  ;: roll ( x#u x#u-1...x#0 u -- x#u-1...x#0 x#u )

  header roll_,"roll",0

  call pop_hl
  ld a,h
  or l
  ret z
  ld b,l
  ld c,l
l5f79h:
  call pop_hl
  push hl
  djnz l5f79h
  pop de
  ld b,c
  dec b
l5f82h:
  pop hl
  call push_hl
  djnz l5f82h
  ld h,d
  ld l,e
  jp push_hl

; --------------------------------------------------------------
  ;: char ( "c" -- )

  ; XXX TODO use `word` instead

  header char_,"char",0

  ld hl,(ip_fvar)
char.skip_blanks:
  inc hl
  ld a,(hl)
  cp space_char
  jr z,char.skip_blanks
  cp cr_char
  jr nz,char.found
  ld l,0 ; result when not found
  jp char.return
char.found:
  ld b,a ; preserve the first char

char.skip_remaining:
  inc hl
  ld a,(hl)
  cp space_char
  jr z,char.restore
  cp cr_char
  jr nz,char.skip_remaining

char.restore:
  ld (ip_fvar),hl
  ld l,b ; get the preserved char
char.return:
  ld h,0x00
  jp push_hl

; --------------------------------------------------------------
  ;: [char] ( "c" -- )

  header bracket_char_,"[char]",immediate

  ld a,(state)
  and a ; compiling?
  jp z,compile_only_error ; error if not compiling

  call char_
  call pop_hl
  ld b,h
  ld c,l
  ld de,lit_
  call compile_call_de
  ; hl = dp
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  ;: paper ( n -- ) zx ; {{{2

  header paper_,"paper",0

  ld a,paper_char
  jp print_a_and_tos

; --------------------------------------------------------------
  ;: ink ( n -- ) zx ; {{{2

  header ink_,"ink",0

  ld a,ink_char
  jp print_a_and_tos

; --------------------------------------------------------------
  ;: bright ( f -- ) zx ; {{{2

  header bright_,"bright",0

  ld a,bright_char
  jp print_a_and_tos

; --------------------------------------------------------------
  ;: flash ( f -- ) zx ; {{{2

  header flash_,"flash",0

  ld a,flash_char
print_a_and_tos:
  call print_a
  call pop_hl
  ld a,l
  jp print_a

; --------------------------------------------------------------
  ;: tab ( -- ) zx ; {{{2

  header tab_,"tab",0

  ld a,tab_char
  jp print_a

; --------------------------------------------------------------
  ;: overprint ( f -- ) zx ; {{{2

  header overprint_,"overprint",0

  ld a,over_char
  jp print_a_and_tos

; --------------------------------------------------------------
  ;: inverse ( f -- ) zx ; {{{2

  header inverse_,"inverse",0

  ld a,inverse_char
  jp print_a_and_tos

; --------------------------------------------------------------
  ;: cat ( n -- ) sf ; {{{2

  header cat_,"cat",0

  call pop_hl
  ld a,l
  ld (drive),a
  ld bc,basic_line_of_cat
  jp return.bc

; --------------------------------------------------------------
  ;: bsave ( -- ) sf ; {{{2

  header bsave_,"bsave",0

; XXX TODO -- rewrite
  ret

; --------------------------------------------------------------
  ;: filename! ( ca len n -- )
  ;:
  ;: Copy a filename to a filename buffer.
  ;:
  ;: ca len = filename
  ;: n      = filename buffer (0 or 1)

  header filename_store_,"filename!",0

  call pop_hl
  ld a,l
  ld de,filename.0
  and a ; filename buffer 0?
  jr z,filename_store.move
  ld de,filename.1
filename_store.move
  ; de = filename buffer address
  push de
  call pop_hl_de
  ld b,d
  ld c,e
  pop de
  ; hl = filename address
  ; de = filename buffer address
  ; bc = filename length
  ldir
  ret

; --------------------------------------------------------------
  ;: dloaded ( a ca len -- ) sf ; {{{2
  ;:
  ;: Load a code file into memory.
  ;: ca len = filename
  ;: a      = memory address

  header dload_,"dloaded",0

  call pop_hl
  ld (file_address),hl
  ld bc,basic_line_of_load
  jp return.bc
  ret

; --------------------------------------------------------------
  ;: dsaved ( a1 len1 ca2 len2 -- ) sf ; {{{2
  ;:
  ;: a1 len1  = memory zone
  ;: ca2 len2 = filename

  header dsaved_,"dsaved",0

; XXX TODO -- rewrite
  ret

; --------------------------------------------------------------
  ;: push-hl_ ( -- x ) cf ; {{{2

  header push_hl_,"push-hl_",0

  call do_constant
  dw push_hl

; --------------------------------------------------------------
  ;: pop-hl_ ( x -- ) cf ; {{{2

  header pop_hl_,"pop-hl_",0

  call do_constant
  dw push_hl

; --------------------------------------------------------------
  ;: push-de-hl_ ( -- x1 x2 ) cf ; {{{2

  header push_de_hl_,"push-de-hl_",0

  call do_constant
  dw push_de_hl

; --------------------------------------------------------------
  ;: pop-hl-de_ ( x1 x2 -- ) cf ; {{{2

  header pop_hl_de_,"pop-hl-de_",0

  call do_constant
  dw pop_hl_de

; --------------------------------------------------------------
  ;: expand ( -- ) sf ; {{{2

  header expand_,"expand",0
  ;: XXX TODO adapt?

  ; XXX TODO -- write "save-system" or similar; rename?
  ld hl,(latest)
  ld (cold_latest),hl
  ld hl,(dp)
  ld (cold_dp),hl
  ld (fence),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  ;: state ( -- a ) 94 ; {{{2

  header state_,"state",0

  call do_variable
state:
  dw 0 ; compilation state flag (non-zero value when in compilation state)

; --------------------------------------------------------------
  ;: bounds ( a n -- a' a ) comus ; {{{2

  header bounds_,"bounds",0

  call over_
  call plus_
  jp swap_

; --------------------------------------------------------------
  ;: [ ( -- ) fig,83,94  "left-bracket" ; {{{2

  header left_bracket_,"[",immediate

  ld hl,false
  ld (state),hl
  ret

; --------------------------------------------------------------
  ;: ] ( -- ) fig,83,94  "right-bracket" ; {{{2

  header right_bracket_,"]",0

  ld hl,true
  ld (state),hl
  ret

; --------------------------------------------------------------
  ;: unused ( -- u ) 94 ; {{{2
  ;:
  ;: Return the amount of space remaining in the region addressed by `here`, in
  ;: address units.
  ;: XXX TODO adapt -- implement and use the heap pointer as top limit

  header unused_,"unused",0

  ld de,(dp)
  ld hl,0x0000
  sbc hl,de
  jp push_hl

; --------------------------------------------------------------
  ;: >in ( -- +n ) 83,94 ; {{{2
  ;:
  ;: Return the address of a cell containing the offset in characters from
  ;: the start of the input buffer to the start of the parse area.

  header to_in_,"to_in",0

  ; XXX TODO -- not used yet
  ; XXX TODO -- convert `ip_fvar`, an absolute address, to `to_in`.
  ld hl,to_in
  jp push_hl
to_in:
  dw 0x0000

; --------------------------------------------------------------
  ;: depth ( -- +n ) 83,94 ; {{{2
  ;:
  ;: Return the number of single-cell (16-bit in this case) values contained in
  ;: the data stack before it was placed on the stack.

  header depth_,"depth",0

  ld hl,(sp0)
  if data_stack_method = ix_dsm
    push ix
    pop de
  else
    ld de,(dsp)
  endif
  sbc hl,de
  ; XXX TODO -- test this:
  srl h
  rr l
  jp push_hl

; --------------------------------------------------------------
  ;: .s ( -- ) 94 ; {{{2
  ;:
  ;: Copy and display the values currently on the data stack.

  header dot_s_,".s",0

  ret

;; XXX TODO -- easier in Forth
;;  call depth_
;;  call pop_hl ; XXX TODO -- pop_bc instead
;;  call dup_
;;  call bounds_
;;  ld b,h
;;  ld c,l
;;dot_s.next

current_latest: equ dot_s_nfa

end_of_code:

end start
