; Couplement Forth {{{1

; This file is part of
; Couplement Forth
; (http://programandala.net/en.program.couplement_forth.html),
; by Marcos Cruz (programandala.net), 2015, 2016, 2020, 2021.

; Couplement Forth is an experimental subroutine-threaded Forth
; system under development for the ZX Spectrum.

  macro version
    ; After Semantic Versioning (http://semver.org)
    db "0.2.0-dev.32.0+20210620T2052CEST"
  endm

; --------------------------------------------------------------
; License

; Copyright (C) 2015,2016,2020,2021 Marcos Cruz (programandala.net)

; You may do whatever you want with this work, so long as you
; retain all copyright notices, all credit notices, and this
; license in all files of all redistributed copies and derived
; works. There is no warranty.

; --------------------------------------------------------------
; Credits

; Couplement Forth was forked from ForthCoupe
; (http://programandala.net/en.program.forthcoupe.html), an
; abandoned Forth for the SAM Coup√©, based on John A. Avis'
; SamForth (http://programandala.net/en.program.samforth.html).

; ==============================================================
; Symbols {{{1

; --------------------------------------------------------------
; Forth

precedence_bit:       equ 6
immediate:            equ 1 << precedence_bit ; bit mask
compile_only_bit:     equ 7
compile_only:         equ 1 << compile_only_bit ; bit mask
interpret_only_bit:   equ 0
interpret_only:       equ 1 << interpret_only_bit ; bit mask

colon_structure_id:   equ $01
do_structure_id:      equ $02
begin_structure_id:   equ $03
if_structure_id:      equ $04
builds_structure_id:  equ $09

; --------------------------------------------------------------
; ZX Spectrum

  include zx_spectrum_system_variables.z80s
  include zx_spectrum_rom_routines.z80s
  include zx_spectrum_char_codes.z80s

; --------------------------------------------------------------
; Other

false:  equ $0000
true:   equ $FFFF
; XXX FIXME -- the legacy code uses 1 as true flag

; ==============================================================
; Assembling options {{{1

; --------------------------------------------------------------
; Data stack method {{{2

; Couplement Forth can use different methods to manage its data
; stack. Every method has a constant identifier:

sp_dsm:  equ 1 ; use SP with the address kept in `dsp`
ix_dsm:  equ 2 ; use IX to hold the stack pointer permanently
ixl_dsm: equ 3 ; use IXl to hold the stack pointer permanently

; The data stack method can be selected here, using one of the
; above identifiers:

data_stack_method:  equ ixl_dsm

; Some stack operations can be faster (though also larger) by manipulating the
; data stack directly, instead of calling the push/pop routines:

; XXX WARNING: Faster stack operations are not supported by the IXl method yet.
faster_stack_operations: equ false

; --------------------------------------------------------------
; Size {{{2

; When size optimization is on, relative jumps are used when
; possible, and some inline code is replaced with calls.  Some
; bytes will be saved, but the code will be a bit slower.

; XXX TODO
size_optimization: equ false

; --------------------------------------------------------------
; Screen {{{2

; XXX TODO
whole_screen: equ false ; does the input line uses the whole screen?

; ==============================================================
; Start {{{1

start: equ 25000

  org start

  jp cold_start
  jp warm_start

; ==============================================================
; Interface to BASIC {{{1

; XXX TODO

filename_length equ 10

drive:
  db 1
filename.0: ; main filename buffer
  ds filename_length
filename.1: ; secondary filename buffer
  ds filename_length
file_address:
  dw 0
file_length:
  dw 0

include fn_dpeek.z80s
include fn_peeks.z80s

basic_line_of_cat     equ 100
basic_line_of_load    equ 110
basic_line_of_save    equ 120
basic_line_of_erase   equ 130
basic_line_of_rename  equ 140

; ==============================================================
; Variables {{{1

; XXX NOTE -- The following two variables
; have to be at a fixed address from the start of the code,
; because they are used by the BASIC loader
; (BASIC sees this code at 0x10000).
svblk_fvar:
; XXX OLD -- used only by the BASIC loader
; Flag used during LOAD, SAVE and DIR commands
; Now its offset is +6.
; XXX TODO -- use a system variable or BC instead?
  dw $0000
slen_fvar:
; XXX OLD -- used only by the BASIC loader
; Length of source to be saved
; Now its offset is +8.
  dw $0000

; XXX TODO -- move all variables into the code, except those shared with the BASIC loader

ip_fvar: ; XXX TODO -- make it standard
  ; Address of interpreter pointer within source being compiled
  dw $0000
numbit_fvar:
  ; Temporary store used during number output
  dw $0000
endf_fvar:
  ; Temporary store used during number output
  dw $0000
etib_fvar: ; XXX OLD -- remove it; adapt the keyboard input code
  ; End address of Terminal Input Buffer
  dw tib_end ; XXX CHECK -- originally tib_start, why?
errhld_fvar:
  ; Address of interpreter pointer position when an error occurred during source compilation
  dw $0000
hlds_fvar:
  ; Temporary store during number formatting
  dw $0000
pairs_fvar:
  ; Flags to indicate whether pairs such as DO-LOOP match up during compilation
  dw $0000
;#smode_fvar: ; XXX CHECK -- why not the system var?
;#; Indicates SAM screen mode 1, 2, 3 or 4
;#  dw $0000
len2_fvar:
  ; Used to increase or decrease length of source during editing
  dw $0000
len1_fvar:
  ; Used to increase or decrease length of source during editing
  dw $0000

; ==============================================================
; Debugging tools {{{1

; Code based on a similar code of "Finen per Imago":
; <http://programandala.net/es.programa.finen_per_imago.html>

debug: equ 0

  macro save_registers
    push iy
    push ix
    push hl
    push de
    push bc
    push af
    exx
    push hl
    push de
    push bc
    push af
    exx
  endm

  macro restore_registers
    exx
    pop af
    pop bc
    pop de
    pop hl
    exx
    pop af
    pop bc
    pop de
    pop hl
    pop ix
    pop iy
  endm

check:

  proc

      local saved_hl
      local message
      local restore
      local print_message
      local return_address

      ld (saved_hl),hl
      pop hl
      ld (message),hl
      save_registers
    message: equ $+1
      ld hl,0
    print_message:
      ld a,(hl)
      inc hl
      and a ; end of text?
      jr z,restore
      call print_a
      jr print_message
    restore:
      ld (return_address),hl
      restore_registers

    saved_hl: equ $+1
      ld hl,0
    return_address: equ $+1
      jp 0

  endp

  macro check,  message,condition
    ;if (nul condition) ? check : check or condition ; XXX FIXME
    if debug
      call check
      db message
      db 0 ; end of message
    endif
  endm

check.char.a:
  save_registers
  call print_a
  restore_registers
  ret

  macro check.char.a
    if debug
      call check.char.a
    endif
  endm

check.print_bc_chars_at_hl:
  push bc
  push hl
  ld a,"{"
  call print_a
  pop hl
  pop bc
  call print_bc_chars_at_hl
  ld a,"}"
  call print_a
  ret

check.cstring.hl:
  save_registers
  ld a,(hl)
  ld b,0
  ld c,a
  inc hl
  call check.print_bc_chars_at_hl
  restore_registers
  ret

  macro check.cstring.hl
    ; print the counted string at HL
    if debug
      call check.cstring.hl
    endif
  endm

check.string.de_b:
  save_registers
  ld c,b
  ld b,0
  ex de,hl
  call check.print_bc_chars_at_hl
  restore_registers
  ret

  macro check.string.de_b
    ; print B characters at DE
    if debug
      call check.string.de_b
    endif
  endm

  macro border,color
    ; change the border to color
    if 0;debug
      push af
      ld a,color
      out ($FE),a
      pop af
    endif
  endm

; ==============================================================
; Data zones {{{1

; XXX TODO -- choose better names for the bounds

tib_start:
  defs $80 ; XXX TODO -- increase after Forth-2012
tib_end:

pad_start:
  defs $FF

if data_stack_method=ixl_dsm
  defs $0080
endif
data_stack_limit:
data_stack_max_top:
  ; The data stack grows from bottom (high memory) to top (low memory)
  if data_stack_method=ixl_dsm
    defs $0080
  else
    defs $0100
  endif
data_stack_bottom:
if data_stack_method=ixl_dsm
  defs $007F
endif

return_stack_limit:
return_stack_max_top:
  ; The return stack grows from bottom (high memory) to top (low memory)
  defs $0100
return_stack_bottom:

; ==============================================================
; Data stack manipulation {{{1

init_data_stack:
  if data_stack_method = sp_dsm
    ld hl,(sp0)
    ld (dsp),hl
  else
    ld ix,(sp0)
  endif
  ret

; --------------------------------------------------------------
if data_stack_method = sp_dsm ; {{{2

; This is the method used by SamForth.
; The stack-limit checks of the original code have been removed.

push_de:

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  push de                     ;  11
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 101 total (100.5 average with pop_de)

pop_de:

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  pop de                      ;  10
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 100 total (100.5 average with push_de)

push_hl:

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  push hl                     ;  11
  ld (dsp),sp                 ;  20
rsp_copy: equ $+1
  ld sp,return_stack_bottom   ;  10
  ret                         ;  10
                              ;  91 total (95.5 average with pop_hl)

pop_hl:

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  pop hl                      ;  10
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 100 total (95.5 average with push_hl)

push_de_hl:

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  push de                     ;  11
  push hl                     ;  11
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 102 total (106 average with pop_hl_de)
pop_hl_de:

                              ; T Cycles
  ld (rsp_copy),sp            ;  20
  ld sp,(dsp)                 ;  20
  pop hl                      ;  10
  pop de                      ;  10
  ld (dsp),sp                 ;  20
  ld sp,(rsp_copy)            ;  20
  ret                         ;  10
                              ; 110 total (106 average with push_hl_de)

endif ; data_stack_method = sp_dsm

; --------------------------------------------------------------
if data_stack_method = ix_dsm ; {{{2

push_de:
                      ; T Cycles
  dec ix              ;  10
  ld (ix),d           ;  19
  dec ix              ;  10
  ld (ix),e           ;  19
  ret                 ;  10
                      ; 068 total (68 average with pop_de)

pop_de:
                      ; T Cycles
  ld e,(ix)           ;  19
  inc ix              ;  10
  ld d,(ix)           ;  19
  inc ix              ;  10
  ret                 ;  10
                      ; 068 total (68 average with push_de)

push_hl:
                      ; T Cycles
  dec ix              ;  10
  ld (ix),h           ;  19
  dec ix              ;  10
  ld (ix),l           ;  19
  ret                 ;  10
                      ; 068 total (68 average with pop_hl)

pop_hl:
                      ; T Cycles
  ld l,(ix)           ;  19
  inc ix              ;  10
  ld h,(ix)           ;  19
  inc ix              ;  10
  ret                 ;  10
                      ; 068 total (68 average with push_hl)

push_de_hl:
                      ; T Cycles
  dec ix              ;  10
  ld (ix),d           ;  19
  dec ix              ;  10
  ld (ix),e           ;  19
  dec ix              ;  10
  ld (ix),h           ;  19
  dec ix              ;  10
  ld (ix),l           ;  19
  ret                 ;  10
                      ; 126 total (126 average with pop_de_hl)

pop_hl_de:
                      ; T Cycles
  ld l,(ix)           ;  19
  inc ix              ;  10
  ld h,(ix)           ;  19
  inc ix              ;  10
  ld e,(ix)           ;  19
  inc ix              ;  10
  ld d,(ix)           ;  19
  inc ix              ;  10
  ret                 ;  10
                      ; 126 total (126 average with push_hl_de)

endif ; data_stack_method = ix_dsm

; --------------------------------------------------------------
if data_stack_method = ixl_dsm ; {{{2

; Credit:
; Idea borrowed from Alone Coder:
; https://spectrumcomputing.co.uk/forums/viewtopic.php?p=68998#p68998

push_de:
                      ; T Cycles
  ld (ix+127),d       ;  19
  db $DD
  dec ix              ;  10 ; dec ixl
  ld (ix-128),e       ;  19
  ret                 ;  10
                      ; 058 total (58 average with pop_de)

pop_de:
                      ; T Cycles
  ld e,(ix-128)       ;  19
  db $DD
  inc ix              ;  10 ; inc ixl
  ld d,(ix+127)       ;  19
  ret                 ;  10
                      ; 058 total (58 average with push_de)

push_hl:
                      ; T Cycles
  ld (ix+127),h       ;  19
  db $DD
  dec ix              ;  10 ; dec ixl
  ld (ix-128),l       ;  19
  ret                 ;  10
                      ; 058 total (58 average with pop_hl)

pop_hl:
                      ; T Cycles
  ld l,(ix-128)       ;  19
  db $DD
  inc ix              ;  10 ; inc ixl
  ld h,(ix+127)       ;  19
  ret                 ;  10
                      ; 058 total (58 average with push_hl)

push_de_hl:
                      ; T Cycles
  ld (ix+127),d       ;  19
  db $DD
  dec ix              ;  10 ; dec ixl
  ld (ix-128),e       ;  19
  ld (ix+127),h       ;  19
  db $DD
  dec ix              ;  10 ; dec ixl
  ld (ix-128),l       ;  19
  ret                 ;  10
                      ; 106 total (106 average with pop_de_hl)

pop_hl_de:
                      ; T Cycles
  ld l,(ix-128)       ;  19
  db $DD
  inc ix              ;  10 ; inc ixl
  ld h,(ix+127)       ;  19
  ld e,(ix-128)       ;  19
  db $DD
  inc ix              ;  10 ; inc ixl
  ld d,(ix+127)       ;  19
  ret                 ;  10
                      ; 106 total (106 average with push_hl_de)

endif ; data_stack_method = ixl_dsm

; ==============================================================
; Keyboard input {{{1

; XXX TODO convert to `accept`

cursor_address:
  ; Address of the cursor in the input buffer
  dw $0000
chars_on_the_left_of_the_cursor:
  ; Length of the input line before the cursor
  db $00
chars_on_the_right_of_the_cursor:
  ; Length of the input line after the cursor
  db $00

keyboard_input:

  ; Init
  ld hl,(tib_address)
  ld (cursor_address),hl
  xor a
  ld (chars_on_the_left_of_the_cursor),a
  ld (chars_on_the_right_of_the_cursor),a

  if not whole_screen
    ld a,$01 ; usually channel "K", lower screen I/O
    call link.a
    call rom_cls_lower
  endif

keyboard_input.next_key:
  push hl
  call refresh_the_command_line
  call key_
  call pop_hl
  ; XXX TODO get the control char routine from a table
  ld a,l ; key code
  pop hl

  if false

  cp 128 ; ASCII?
  jp nc,keyboard_input.next_key ; not ASCII
  cp " " ; printable?
  jr c,printable_char ; yes
  ; control char
  cp 15 ; not used control char (>14)?
  jp nc,keyboard_input.next_key ; yes
  cp 6 ; not used control char (<6)?
  jp c,keyboard_input.next_key ; yes

  ; XXX TODO jump table here

  else

;  cp $00 ; XXX TODO adapt, how?
;  jp z,keyboard_input.delete_right
;  cp $00 ; XXX TODO adapt, how?
;  jp z,keyboard_input.delete_until_end_of_line
  cp caps_char ; 6
  jp z,toggle_caps_lock
  cp edit_char ; 7
  jp z,keyboard_input
  cp cursor_left_char ; 8
  jp z,keyboard_input.cursor_left
  cp cursor_right_char ; 9
  jp z,keyboard_input.cursor_right
  cp cursor_down_char ; 10
  jp z,keyboard_input.cursor_down
  cp cursor_up_char ; 11
  jp z,keyboard_input.cursor_up
  cp delete_left_char ; 12
  jp z,keyboard_input.delete_left
  cp cr_char ; 13
  jp z,keyboard_input.cr
  cp extended_mode_char ; 14 ; XXX TMP
  jp z,toggle_overwrite_mode
  cp 128 ; ASCII?
  jp nc,keyboard_input.next_key ; not ASCII

  endif

  ; XXX FIXME -- strange things happen
printable_char:
  ; a = char code
  push af
overwrite_mode_flag: equ $+1
  ld a,0 ; 0 or 1
  and a ; ovewrite mode?
  call z,sub_4f54h ; no
  ; insert mode
  pop af
  ld (hl),a
  inc hl
  ld (cursor_address),hl
  ld a,(chars_on_the_left_of_the_cursor)
  inc a
  ld (chars_on_the_left_of_the_cursor),a
  ld a,(overwrite_mode_flag)
  and a
  jr z,keyboard_input.next_key
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jr z,keyboard_input.next_key
  dec a
  ld (chars_on_the_right_of_the_cursor),a
  jp keyboard_input.next_key

toggle_caps_lock:
  ld a,(sys_flags2)
  xor $08
  ld (sys_flags2),a
  jp keyboard_input.next_key

keyboard_input.cr:
  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld c,a
  ld b,$00
  add hl,bc
  ld (hl),cr_char
  ld (etib_fvar),hl

  if not whole_screen
    call rom_cls_lower
    ld a,$02 ; usually channel "S", upper screen I/O
    call link.a
  endif

  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c

  if whole_screen

    ret

  else

    ld b,$00
    jp print_bc_chars_at_hl_or_nothing

  endif

keyboard_input.delete_left:
  ld a,(chars_on_the_left_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_left_of_the_cursor),a
  ld hl,(cursor_address)
  ld d,h
  ld e,l
  dec de
  ld (cursor_address),de
  ld a,(chars_on_the_right_of_the_cursor)

keyboard_input.move_a_chars_from_hl_to_de:
  and a
  jr z,keyboard_input.no_move_needed
  ld c,a
  ld b,$00
  ldir
keyboard_input.no_move_needed:
  ld hl,(cursor_address)
  jp keyboard_input.next_key

keyboard_input.delete_right:
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_right_of_the_cursor),a
  ld hl,(cursor_address)
  inc hl
  ld de,(cursor_address)
  jp keyboard_input.move_a_chars_from_hl_to_de

keyboard_input.cursor_left:
  ld a,(chars_on_the_left_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_left_of_the_cursor),a
  ld a,(chars_on_the_right_of_the_cursor)
  inc a
  ld (chars_on_the_right_of_the_cursor),a
  dec hl
  ld (cursor_address),hl
  jp keyboard_input.next_key

keyboard_input.cursor_right:
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jp z,keyboard_input.next_key
  dec a
  ld (chars_on_the_right_of_the_cursor),a
  ld a,(chars_on_the_left_of_the_cursor)
  inc a
  ld (chars_on_the_left_of_the_cursor),a
  inc hl
  ld (cursor_address),hl
  jp keyboard_input.next_key

keyboard_input.delete_until_end_of_line:
  xor a
  ld (chars_on_the_right_of_the_cursor),a
  jp keyboard_input.next_key

keyboard_input.cursor_up:
  ; goto the start of the line
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld (chars_on_the_right_of_the_cursor),a
  xor a
  ld (chars_on_the_left_of_the_cursor),a
  ld hl,(tib_address)
  ld (cursor_address),hl
  jp keyboard_input.next_key

keyboard_input.cursor_down:
  ; goto the end of the line
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld (chars_on_the_left_of_the_cursor),a
  ld c,a
  xor a
  ld (chars_on_the_right_of_the_cursor),a
  ld b,$00
  ld hl,(tib_address)
  add hl,bc
  ld (cursor_address),hl
  jp keyboard_input.next_key

sub_4f54h:
  ; XXX TODO -- document
  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  ld c,a
  ld a,(chars_on_the_right_of_the_cursor)
  add a,c
  ld c,a
  ld b,$00
  add hl,bc
  ld (etib_fvar),hl
  ld a,(chars_on_the_right_of_the_cursor)
  inc a
  ld c,a
  ld de,(etib_fvar)
  inc de
  lddr
  ld hl,(cursor_address)
  ret

toggle_overwrite_mode:
  ld a,(overwrite_mode_flag)
  xor $01
  ld (overwrite_mode_flag),a
  jp keyboard_input.next_key

refresh_the_command_line:

  if whole_screen

    ld a,(chars_on_the_left_of_the_cursor)
    and a
    jr z,line_cleared
    inc a
    ld b,a
  backspace_to_left_margin:
    push bc
    ld a,backspace_char
    call print_a
    pop bc
    djnz backspace_to_left_margin

  else

    call home_ ; bottom screen

  endif

line_cleared:
  ld hl,(tib_address)
  ld a,(chars_on_the_left_of_the_cursor)
  and a
  jr z,print_cursor
  ld c,a
  ld b,$00
  call print_bc_chars_at_hl
print_cursor:
  ld hl,cursor
  ld a,(overwrite_mode_flag)
  and a
  jr nz,print_cursor.do
  inc hl
print_cursor.do:
  ld a,(hl)
  call print_a
  ld hl,(cursor_address)
  ld a,(chars_on_the_right_of_the_cursor)
  and a
  jr z,print_trailing_space
  ld c,a
  ld b,$00
  call print_bc_chars_at_hl
print_trailing_space:
  jp space_ ; needed when a char has been deleted

cursor:
  db 143 ; overwrite mode ; XXX TMP!
  db "_" ; insert mode

; ==============================================================
; Text output {{{1

print_bc_chars_at_hl:
  ; XXX TODO-- faster version por 0-255 chars?
  ld a,(hl)
  inc hl
  push hl
  push bc
  call print_a
  pop bc
  pop hl
  dec bc
print_bc_chars_at_hl_or_nothing:
  ld a,b
  or c
  jr nz,print_bc_chars_at_hl
  ret

print_inline_message:
  ; Print a message stored rigth after the call.
  ; The message has the bit 7 of its last char set.
  ; XXX TODO -- use counted strings instead
  pop hl
  call print_message_at_hl
  jp (hl)

print_table_message:
  ; Print the A-th message (zero is the first) of a table stored at HL.
  ; Every message in the table has the bit 7 of its last char set.
  dec a
  jr z,print_message_at_hl
  ex af,af'
skip_message:
  ld a,(hl)
  inc hl
  and $80
  jr z,skip_message
  ex af,af'
  jr print_table_message

print_message_at_hl:
  ; Print a message stored at HL.
  ; The message has the bit 7 of its last char set.
  ld a,(hl)
  inc hl
  bit 7,a
  push af
  res 7,a
  call print_a
  pop af
  jr z,print_message_at_hl
  ; hl = address after the last char
  ret

wrap_print_message_at_hl:
  ; Print (left justified) a message stored at HL.
  ; The message has the bit 7 of its last char set.

  ; XXX TODO

wrap_print_message_at_hl.next_word:

  push hl ; save the start address
  ld b,0x0 ; char count

wrap_print_message_at_hl.next_char:
  ld a,(hl)
  inc hl
  inc b
  bit 7,a
  res 7,a
  jr nz,wrap_print_message_at_hl.end_of_message_found
  cp space_char
  jr nz,wrap_print_message_at_hl.next_char

wrap_print_message_at_hl.end_of_word_found:

  ; inc ; XXX TODO
  jr z,wrap_print_message_at_hl.next_char

wrap_print_message_at_hl.end_of_message_found:

; wrap_print_message_at_hl.next_word: ; XXX TODO
  pop hl

  ; hl = message address
  ; b = message length

  ret

; ==============================================================
; Errors {{{1

error.stack_overflow:               equ -003
error.stack_underflow:              equ -004
error.return_stack_overflow:        equ -005
error.return_stack_underflow:       equ -006
error.dictionary_overflow:          equ -008
error.division_by_zero:             equ -010
error.not_found:                    equ -013
error.compilation_only:             equ -014
error.invalid_forget:               equ -014
error.zero_length_name:             equ -016
error.control_structure_mismatch:   equ -022

stack_overflow_error:
  ld hl,error.stack_overflow
  jr error_hl
stack_underflow_error:
  ld hl,error.stack_underflow
  jr error_hl
return_stack_overflow_error:
  ld hl,error.return_stack_overflow
  jr error_hl
return_stack_underflow_error:
  ld hl,error.return_stack_underflow
  jr error_hl
division_by_zero_error:
  ld hl,error.division_by_zero
  jr error_hl
not_found_error:
  ; XXX TODO -- print the offending word
  ld hl,error.not_found
  jr error_hl
compilation_only_error:
  ; XXX TODO -- print the offending word
  ld hl,error.compilation_only
  jr error_hl
invalid_forget_error:
  ld hl,error.invalid_forget
  jr error_hl
zero_length_name_error:
  ld hl,error.zero_length_name
  jr error_hl
control_structure_mismatch_error:
  ; XXX TODO -- print the offending word
  ld hl,error.control_structure_mismatch

error_hl:
  call push_hl
  call print_inline_message
  db "Error: ","#"+$80
  call dot_

  ; init after an error
  ;;check "init after an error"
  ; XXX TODO -- factor this
  call init_data_stack
  ;;check "init after an error -- aftor call init_data_stack"
  ld (svblk_fvar),a
  ld hl,(ip_fvar)
  ld (errhld_fvar),hl
;; XXX ? -- not needed?:
  ld hl,tib_start
  ld (tib_address),hl
  ld hl,pad_start
  ld (pad_address),hl
  ;;check "init after an error -- before call restore_dictionary_pointers"
  call restore_dictionary_pointers
  ;;call cr_ ; XXX ? --- needed?
  xor a
  ld (double_number_flag),a
  ;;check "init after an error -- before jp quit_"
  jp quit_

; ==============================================================
; Entry points  {{{1

cold_start:
  di
  ld (saved_basic_sp),sp
  ld sp,(rp0)
  ei
  ld a,$02 ; usually channel "S", upper screen I/O
  call link.a
  jp cold_

warm_start:
  di
  ld (saved_basic_sp),sp
  ld sp,(rp0)
  ei
  jp quit_

; ==============================================================
; Dictionary tools {{{1

save_dictionary_pointers:
  ld hl,(dp)
  ld (saved_dp),hl
  ld hl,(latest)
  ld (saved_latest),hl
  ret

restore_dictionary_pointers:
  ; XXX -- called only after an error, but maybe useful in the future (e.g. for `catch`)
saved_dp: equ $+1
  ld hl,0
  ld (dp),hl
saved_latest: equ $+1
  ld hl,0
  ld (latest),hl
  ret

; XXX TODO -- factor to a word (`?struc`, `?pairs` ?)
; XXX TODO -- rename the original "sub_5743h" name in SamForth
structured:
  ; (sp) = flow structure code compiled in the current word
  ; a = flow structure code to compare
  call pop_hl
  cp l
  jp nz,control_structure_mismatch_error
  ret

; ==============================================================
; Dictionary {{{1

_previous_nfa: defl 0

  macro header, label_,name,flags,previous ; {{{2

    ; Create a word header in the dictionary

    ; label_ = label-format name (with a "_" suffix)
    ; name = string with the actual name
    ; flags = byte with the precedence and compile-only bits combined

    label_##flags_field:  db flags
    label_##lfa:          dw _previous_nfa
    _previous_nfa:        defl $
    label_##nfa:          db label_##cfa-$-1,name
    label_:
    label_##cfa:

  endm

; --------------------------------------------------------------
  header couplement_forth_,'couplement-forth',0 ; {{{2

; doc{
;
; couplement-forth ( -- )
;
; Noop word. If present, the program is running on Couplement Forth.
; Intended for conditional compilation in portable programs.
;
; }doc

  ret

; --------------------------------------------------------------
  header paren_bootmessage_,'(bootmessage)',0 ; {{{2

; doc{
;
; (bootmessage) ( -- )
;
; Print the Couplement Forth boot message.
;
; }doc

  call print_inline_message
  db "Couplement Forth",cr_char
  version
  db cr_char
  db "By Marcos Cruz",cr_char
  db "(programandala.net), 2015, 2016,",cr_char
  db "2020",cr_char+$80
  ret

; --------------------------------------------------------------
  header bootmessage_,'bootmessage',0 ; {{{2

; doc{
;
; bootmessage ( -- )
;
; Print a boot message (Couplement Forth's boot message by default).
;
; ``bootmessage`` is a deferred word. Its action can be changed with `is` or
; `defer!`.
;
; }doc

  jp paren_bootmessage_

; --------------------------------------------------------------
  header c_lit_,'clit',0

; doc{
;
; clit ( -- b )
;
; Push the content of the next address unit to the data stack as a literal.
;
; }doc

  pop hl ; address of the literal
  ld e,(hl)
  ld d,0
  inc hl
  push hl ; return address
  ex de,hl
  jp push_hl

; --------------------------------------------------------------
  header lit_,'lit',0 ; {{{2

; doc{
;
; lit ( -- x )
;
; Push the content of the next cell to the data stack as a literal.
;
; ``lit`` is compiled by `literal`.
;
; }doc

  pop hl ; address of the literal
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl ; return address
  call push_de
  jp (hl)

; --------------------------------------------------------------
  header literal_,'literal',immediate+compile_only ; {{{2

; doc{
;
; literal
;  Interpretation:
;    Interpretation semantics for this word are undefined.
;  Compilation: ( x -- )
;    Append the run-time semantics given below to the current definition.
;  Run-time: ( -- x )
;    Place x on the stack.
;
; }doc

  ; XXX FIXME --

  ld de,lit_
  call compile_call_de
  call pop_de
  jp compile_de

; --------------------------------------------------------------
  header to_body_,'>body',0 ; {{{2

; doc{
;
; >body ( cfa -- pfa )
;
;  XXX TODO -- doc
; ( xt -- a-addr ) a-addr is the data-field address corresponding to xt. ; {{{2
;  An ambiguous condition exists if xt is not for a word defined via CREATE.
;
; }doc

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      inc hl
      inc hl
      inc hl
      ld (ix),h
      dec ix
      ld (ix),l
    endif
    if data_stack_method = ixl_dsm
      ld l,(ix-128)
      db $DD
      inc ix
      ld h,(ix+127)
      inc hl
      inc hl
      inc hl
      ld (ix+127),h
      db $DD
      dec ix
      ld (ix-128),l
    endif
    if data_stack_method = sp_dsm
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      inc de
      inc de
      inc de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    inc hl
    inc hl
    inc hl
    jp push_hl
  endif

; --------------------------------------------------------------
  header two_minus_,'2-',0 ; {{{2

; doc{
;
; 2- ( n1|u1 -- n2|u2 )
;
;  Subtract two (2) from n1|u1 giving the difference n2|u2.
;
; }doc

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      dec hl
      dec hl
      ld (ix),h
      dec ix
      ld (ix),l
    endif
    if data_stack_method = ixl_dsm
      ld l,(ix-128)
      db $DD
      inc ix
      ld h,(ix+127)
      dec hl
      dec hl
      ld (ix+127),h
      db $DD
      dec ix
      ld (ix-128),l
    endif
    if data_stack_method = sp_dsm
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      dec de
      dec de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    dec hl
    dec hl
    jp push_hl
  endif

; --------------------------------------------------------------
  header two_plus_,'2+',0 ; {{{2

; doc{
;
; 2+ ( n1|u1 -- n2|u2 )
;
;  Add two (2) to n1|u1 giving the sum n2|u2.
;
; }doc

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      inc hl
      inc hl
      ld (ix),h
      dec ix
      ld (ix),l
    endif
    if data_stack_method = ixl_dsm
      ld l,(ix-128)
      db $DD
      inc ix
      ld h,(ix+127)
      inc hl
      inc hl
      ld (ix+127),h
      db $DD
      dec ix
      ld (ix-128),l
    endif
    if data_stack_method = sp_dsm
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      inc de
      inc de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    inc hl
    inc hl
    jp push_hl
  endif

; --------------------------------------------------------------
  header one_minus_,'1-',0 ; {{{2

; doc{
;
; 1- ( n1|u1 -- n2|u2 )
;
;  Subtract one (1) from n1|u1 giving the difference n2|u2.
;
; }doc

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      dec hl
      ld (ix),h
      dec ix
      ld (ix),l
    endif
    if data_stack_method = ixl_dsm
      ld l,(ix-128)
      db $DD
      inc ix
      ld h,(ix+127)
      db $DD
      dec hl
      ld (ix+127),h
      db $DD
      dec ix
      ld (ix),l
    endif
    if data_stack_method = sp_dsm
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      dec de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    dec hl
    jp push_hl
  endif

; --------------------------------------------------------------
  header one_plus_,'1+',0 ; {{{2

; doc{
;
; 1+ ( n1|u1 -- n2|u2 )
;
;  Add one (1) to n1|u1 giving the sum n2|u2.
;
; }doc

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld l,(ix)
      inc ix
      ld h,(ix)
      inc ix
      inc hl
      ld (ix),h
      dec ix
      ld (ix),l
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      inc de
      ld (hl),d
      dec hl
      ld (hl),e
    endif
    ret
  else
    call pop_hl
    inc hl
    jp push_hl
  endif

; --------------------------------------------------------------
  header execute_,'execute',0 ; {{{2

; doc{
;
; execute ( cfa -- )
;
; }doc

  call pop_hl
  jp (hl)

; --------------------------------------------------------------
  header perform_,'perform',0 ; {{{2

; doc{
;
; perform ( a -- )
;
; }doc

  call pop_hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  ret z
  jp (hl)

; --------------------------------------------------------------
  header prompt_,'prompt',0 ; {{{2

; doc{
;
; prompt ( -- ) ( R: i*x -- )
;
; Print the system prompt.
;
; }doc

  ; XXX TODO -- Gforth prints "compiled" in compiling state.
  call print_inline_message
  db " o"
  db "k"+$80
  ret

; --------------------------------------------------------------
  header quit_,'quit',0 ; {{{2

; doc{
;
; quit ( -- ) ( R: i*x -- )
;
; Empty the return stack, store zero in `source-id` if it is present, make
; the user input device the input source, and enter interpretation state.
; Do not display a message.  Repeat the following:
;
; - Accept a line from the input source into the input buffer, set `>in` to
; zero, and interpret.
;
; - Display the implementation-defined system prompt if in interpretation
; state, all processing has been completed, and no ambiguous condition
; exists.
;
; }doc

  ; clear the return stack:
  di ; XXX ? -- needed?
  ld sp,(rp0) ; reset the return stack
  ei ; XXX ? -- needed?
  ; store zero in `source-id` ; XXX TODO
  ; make the user input device the input source ; XXX TODO
  ; enter intepretation state:
  call left_bracket_

quit.do:
;;  check "before call keyboard_input"
  call cr_
  call keyboard_input ; XXX TODO -- this will depend on the current input source
  call space_
  ; XXX TODO -- set `>in` to zero
;;  check "before call interpret_"
  call interpret_
  ld a,(state)
  and a ; compiling?
  call z,prompt_
  jp quit.do

; --------------------------------------------------------------
  header branch_,'branch',0 ; {{{2

; doc{
;
; branch ( -- )
;
; }doc

  pop hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ret

; --------------------------------------------------------------
  header question_exit_,'?exit',0 ; {{{2

; doc{
;
; ?exit ( f -- )
;
; }doc

  call pop_hl
  ld a,l
  cp h
  ret nz
  jp (hl)

; --------------------------------------------------------------
  header zero_exit_,'0exit',0 ; {{{2

; doc{
;
; 0exit ( f -- )
;
; }doc

  call pop_hl
  ld a,l
  cp h
  ret z
  jp (hl)

; --------------------------------------------------------------
  header question_branch_,'?branch',0 ; {{{2

; doc{
;
; ?branch ( f -- )
;
; }doc

  call pop_hl
  ld a,l
  cp h
  jp nz,branch_
  pop hl
  inc hl
  inc hl
  jp (hl)

; --------------------------------------------------------------
  header zero_branch_,'0branch',0 ; {{{2

; doc{
;
; 0branch ( f -- )
;
; }doc

  call pop_hl
  ld a,l
  cp h
  jp z,branch_
  pop hl
  inc hl
  inc hl
  jp (hl)

; --------------------------------------------------------------
  header swap_,'swap',0 ; {{{2

; doc{
;
; swap ( x1 x2 -- x2 x1 )
;
; }doc

  ; XXX TODO -- faster optional alternative
  call pop_hl_de
  ex de,hl
  jp push_de_hl

; --------------------------------------------------------------
  header dup_,'dup',0 ; {{{2

; doc{
;
; dup ( x -- x x )
;
; Duplicate the cell on the top of the stack.
;
; }doc

  if faster_stack_operations
    if data_stack_method = ix_dsm
      ld e,(ix+0)
      ld d,(ix+1)
      ld (ix-1),d
      ld (ix-2),e
      dec ix
      dec ix
      ret
    else
      ld hl,(dsp)
      ld e,(hl)
      inc hl
      ld d,(hl)
      jp push_de
    endif
  else
    call pop_hl
    call push_hl
    jp push_hl
  endif

; --------------------------------------------------------------
  header question_dup_,'?dup',0 ; {{{2

; doc{
;
; ?dup ( x -- 0 | x x )
;
; Duplicate the cell on the top of the stack if it is non-zero.
;
; }doc

  call pop_hl
  ld a,h
  or l
  call nz,push_hl
  jp push_hl

; --------------------------------------------------------------
  header nip_,'nip',0 ; {{{2

; doc{
;
; nip ( x1 x2 -- x2 )
;
; }doc

  if faster_stack_operations and (data_stack_method = ix_dsm)
    ld l,(ix+0)
    ld h,(ix+1)
    ld (ix+2),l
    ld (ix+3),h
    inc ix
    inc ix
    ret
  else
    call pop_hl
    push hl
    call pop_hl
    pop hl
    jp push_hl
  endif

; --------------------------------------------------------------
  header drop_,'drop',0 ; {{{2

; doc{
;
; drop ( x -- )
;
; }doc

  if data_stack_method = ix_dsm
    inc ix
    inc ix
    ret
  else
    jp pop_hl
  endif

; --------------------------------------------------------------
  header interpret_,'interpret',0 ; {{{2

; doc{
;
; interpret ( -- )
;
; }doc

  ; XXX TODO -- factor

  ld hl,(tib_address)
  dec hl
interpret.skip_space:
  ;;check "at interpret.skip_space"
  ; hl = address of the last char parsed
  inc hl
  ld a,(hl)
  cp space_char
  jp z,interpret.skip_space ;
;  cp standard_tab_char ; XXX TODO -- experimental
;  jr z,interpret.skip_space
  cp cr_char
  ret z

  ; First char to interpret found
  ; XXX TODO -- "inc hl" here would save one loop in "(find)"
  ld (ip_fvar),hl ; XXX TODO -- use "ex de,hl"...
  call paren_find_ ; XXX TODO -- ...and use other entry point
  call pop_hl
  ; hl = cfa or zero
  ld a,h
  or l
  jp nz,interpret.word_found

  ; the word was not found
  check "the word was not found "
  ld hl,(ip_fvar)
  call number_hl
  ld hl,(numbit_fvar) ; XXX TODO -- check if this variable is actually needed
  ld (ip_fvar),hl
  call pop_hl
  ld a,h
  or l
  jp z,l520ah
  ld a,$FF
  ld (double_number_flag),a
  call push_hl
l520ah:
  ld a,(state)
  and a ; executing?
  jp z,l5242h ; jump if executing
  ; compiling:
double_number_flag: equ $+1
  ld a,0
  and a
  jp nz,l521fh
  call swap_
l521fh:
  call pop_hl
  ld b,h
  ld c,l
  ld hl,lit_
  call push_hl
  call compile_call_tos
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ld a,(double_number_flag)
  and a
  jp nz,l5242h
  xor a
  ld (double_number_flag),a
  jp l521fh
l5242h:
  ld hl,(ip_fvar)
  jp interpret.skip_space

interpret.word_found:
  check "interpret.word_found:"
  ; hl = nfa of the word found
flags_field: equ $+1
  ld a,0
  bit precedence_bit,a
  jp nz,interpret.execute

  ; it's not an immediate word
  ld a,(state)
  and a ; compiling?
  jp nz,interpret.compile_non_immediate_word

  ; compiling a not immediate word
  ld a,(flags_field)
  bit compile_only_bit,a ; compile-only?
  jp z,interpret.execute
  ; it's not a compile word
  ld a,(state)
  and a ; compiling?
  jp z,compilation_only_error

interpret.execute:
  ; execute the word
  ;;check "execute the word"
  call push_hl ; XXX TODO -- remove...
  ;;check "before call execute_"
  call execute_ ; XXX TODO -- ...and execute the word directly
  ;;check "after call execute_"
  ld hl,(ip_fvar)
  ;;check "before jp interpret.skip_space"
  jp interpret.skip_space

interpret.compile_non_immediate_word:
  ; compiling a non-immediate word
  ld a,(flags_field)
  bit compile_only_bit,a ; compile-only?
  jp nz,interpret.execute
  call push_hl
  call compile_call_tos
  ld hl,(ip_fvar)
  jp interpret.skip_space

  ; XXX TODO -- factor:
compile_de:
  ld hl,(dp)
  jp compile_de_at_hl

compile_call_tos:
  call pop_hl
  ex de,hl

compile_call_de:
  ld hl,(dp)
  ld (hl),$CD ; Z80 `call`
  inc hl

compile_de_at_hl:
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (dp),hl
  ret

  ; XXX TODO convert this into a word
compile_jp_de:
  ld hl,(dp)
  ld (hl),$C3 ; Z80 `jp`
  inc hl
  jp compile_de_at_hl

; --------------------------------------------------------------
  header paren_find_,'(find)',0 ; {{{2

; doc{
;
; (find) ( -- 0 | cfa )
;
; }doc

  ld de,(ip_fvar) ; address of the name to be searched for
  ;;push de ; XXX TMP -- debugging
  ld b,$00 ; char count

  ; XXX TODO -- study: use HL and A instead of DE and B, to save commands later:
paren_find.parse_name:
  ld a,(de)
  cp space_char
  jp z,paren_find.name_complete
  cp cr_char
  jp z,paren_find.name_complete
;  cp standard_tab_char ; XXX TODO -- experimental
;  jp z,paren_find.name_complete
  inc b ; char count
  inc de ; point to next char
  jp paren_find.parse_name

paren_find.name_complete:
  ; de = address+1 of the last char of the name ; XXX -- not used
  ; b = name length

  ld de,(ip_fvar) ; XXX TMP -- debugging
;;  check "Name1:"
  check.string.de_b

  ld a,b
  ld (length_of_name_searched_for),a
  ld hl,(latest) ; nfa of the first dictionary word to compare to

compare_the_names:
  ; hl = nfa of a word in the dictionary

;;  cp 1
;;  jr nz,no_check
;;  check "="
  ;check.cstring.hl
;;no_check:

length_of_name_searched_for: equ $+1
  ld a,$00 ; length of the name searched for
  cp (hl) ; lengths are equal?
  jp nz,the_names_are_different
  ; lengths are equal
;;  check "=L"
  push hl ; save the nfa of the dictionary word
  ld de,(ip_fvar)
  ld b,a
  ; de = address of the name to be searched for
  ; b = its length
;;  check "Name2:"
  check.string.de_b

next_char:
;;  check "next char"
  inc hl
  ; de = address of current char of the name to be searched for
  ; b = its remaining length
  ; hl = address of the current char of a word's name in the dictionary
  ld c,(hl)
  ld a,(de)

  ; convert the char in the A register to lowercase if needed
  cp "A"
  jp c,compare_char ; jump if lower than "A"
  cp "Z"+1
  jp nc,compare_char ; jump if higher than "Z"
  or %100000 ; convert to lowercase

compare_char:
;;  check "Compare:"
  check.char.a
  cp c
  jp nz,one_char_is_different
  inc de
  djnz next_char

  ; the name has been found in the dictionary
  dec de ; XXX NOTE -- needed, checked!
  ld (ip_fvar),de
  pop de ; nfa of the dictionary word
  dec de
  dec de
  dec de ; flags field address of the dictionary word
  ex de,hl
  ld a,(hl) ; contents of the flags field
  ld (flags_field),a ; needed by `interpret` later
  ex de,hl
  inc hl
  ; hl = cfa of the dictionary word
  jp push_hl ; return the cfa of the dictionary word

one_char_is_different:
;;  check "!c"
  pop hl ; restore the nfa of the dictionary word
the_names_are_different:
;;  check "!n"
  ; hl = nfa of the dictionary word
  dec hl ; to high byte of lfa
  ld a,(hl)
  dec hl ; to low byte of lfa
  ld c,(hl)
  ld h,a
  ld l,c
  ; hl = nfa of the previous word, or 0 if end of dictionary
  or l ; end of dictionary?
  jp nz,compare_the_names
  ; end of dictionary
  jp push_hl ; return 0

; --------------------------------------------------------------
  header u_mult_,'u*',0 ; {{{2

; doc{
;
; u* ( u1 u2 -- du ) ; XXX TODO -- 2020-05-27: Confirm stack
;
; }doc

  call pop_hl_de
  ld b,h
  ld a,l
  call sub_5324h
  push hl
  ld h,a
  ld a,b
  ld b,h
  call sub_5324h
  pop de
  ld c,d
  add hl,bc
  adc a,$00
  ld d,l
  ld l,h
  ld h,a
  jp push_de_hl

sub_5324h:
  ld hl,$0000
  ld c,$08
l5329h:
  add hl,hl
  rla
  jp nc,l5330h
  add hl,de
  adc a,$00
l5330h:
  dec c
  jp nz,l5329h
  ret

; --------------------------------------------------------------
  header plus_,'+',0 ; {{{2

; doc{
;
; + ( n1 n2 -- n3 )
;
; }doc

  call pop_hl_de
  add hl,de
  jp push_hl

; --------------------------------------------------------------
  header plus_store_,'+!',0 ; {{{2

; doc{
;
; +! ( n a -- )
;
; }doc

  call pop_hl_de
  ; hl = address
  ; de = number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  ret

; --------------------------------------------------------------
  header d_plus_,'d+',0 ; {{{2

; doc{
;
; d+ ( n1 n2 -- d ) ; XXX TODO -- 2020-05-27: Confirm stack
;
; }doc

  call pop_hl
  ld b,h
  ld c,l
  call pop_hl
  push hl
  call swap_
  call pop_hl
  pop de
  add hl,de
  ex de,hl
  push af
  call pop_hl
  pop af
  adc hl,bc
  jp push_de_hl

; --------------------------------------------------------------
  header within_,'within',0 ; {{{2

; doc{
;
; within ( n1|u1 n2|u2 n3|u3 -- flag )
;
; Perform a comparison of a test value n1|u1 with a lower limit n2|u2 and an
; upper limit n3|u3, returning true if either (n2|u2 < n3|u3 and (n2|u2 <=
; n1|u1 and n1|u1 < n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
; n3|u3)) is true, returning false otherwise.  An ambiguous condition exists
; if n1|u1, n2|u2, and n3|u3 are not all the same type.
;
; }doc

  ; DZX-Forth:
  ;     pop hl
  ;     pop de
  ;     call hl_minus_de_to_hl
  ;     ex (sp),hl
  ;     call hl_minus_de_to_hl
  ;     jp u_greater.1
  ; Forth-94:
  ;     OVER - >R - R>  U<

  ; XXX checked
  ; XXX TODO faster, in low level
  call over_
  call minus_
  call to_r_
  call minus_
  call r_from_
  jp u_less_than_

; --------------------------------------------------------------
  header minus_,'-',0 ; {{{2

; doc{
;
; - ( n1 n2 -- n3 )
;
; }doc

  call pop_hl_de
  ex de,hl
  sbc hl,de
  jp push_hl

; --------------------------------------------------------------
  header negate_,'negate',0 ; {{{2

; doc{
;
; negate ( n1 -- n2 )
;
; See: `invert`, `0=`.
;
; }doc

  call pop_de
  ld hl,$0000
  sbc hl,de
  jp push_hl

; --------------------------------------------------------------
  header d_negate_,'dnegate',0 ; {{{2

; doc{
;
; dnegate ( d1 -- d2 )
;
; }doc

  call pop_hl_de
  sub a
  sub e
  ld e,a
  xor a
  sbc a,d
  ld d,a
  xor a
  sbc a,l
  ld l,a
  xor a
  sbc a,h
  ld h,a
  jp push_de_hl

; --------------------------------------------------------------
  header number_,'number',0 ; {{{2

; doc{
;
; number ( ca -- n | d )
;
; ca = address of the first char ; XXX ;: TODO -- confirm
;
; Convert the ASCII characters in the input buffer or source code area into
; a double precision number. If the number is below 65536 convert it into a
; single precision number.
;
; }doc

  call pop_hl
number_hl:
  ld a,(hl)
  cp "-"
  jp nz,l53f1h ; not a negative number

  ; negative number
  inc hl
  ld a,$01 ; XXX TODO -- remove?, because a<>0; check how this flag is used later... no way, several bits are used apart
  ld (negative_number_flags),a

l53f1h:
  xor a
  ld (endf_fvar),a
  ex de,hl
  ld hl,$0000
  ld (number_part_1),hl
  ld (number_part_2),hl
l5400h:
  ld a,(de)
  cp "0" ; any invalid digit?
;;  check "undefined 1"
  jp c,not_found_error
  ld c,a
  ld a,(base)
  ld b,$0A
  cp b ; base 10?
  jp nc,l5415h
  add a,"0"
  cp c
  check "undefined 2"
  jp c,not_found_error
l5415h:
  ld a,c
  cp $3A
  jp nc,l5477h
  sub $30
l541ch:
  ld h,$00
  ld l,a
  call push_hl
  inc de
  ld a,(de)
  cp space_char
  jp z,l5470h
  cp $0D
  jp z,l5470h
l542ch:
  dec de
  ld (numbit_fvar),de
  ld hl,(number_part_1)
  call push_hl
  ld hl,(base)
  call push_hl
  call u_mult_
  call pop_hl
  ld hl,(base)
  call push_hl
  ld hl,(number_part_2)
  call push_hl
  call u_mult_
  call d_plus_
  call pop_hl
  ld (number_part_1),hl
  call pop_hl
  ld (number_part_2),hl
  ld a,(endf_fvar)
  cp $01
  jp z,l53beh
  ld de,(numbit_fvar)
  inc de
  jp l5400h

l5470h:
  ld a,$01
  ld (endf_fvar),a
  jp l542ch

l5477h:
  ld c,a
  ld a,(base)
  add a,$37
  cp c
  check "undefined 3"
  jp c,not_found_error
  ld a,c
  sub $37
  jp l541ch

l53beh:
number_part_1: equ $+1
  ld hl,0x000
number_part_2: equ $+1
  ld de,0x000
  call push_de_hl
negative_number_flags: equ $+1
  ld a,$00 ; flags for negative number (bits 1 and 7)
  cp $01 ; XXX OLD ; XXX TODO --
;;  and a ; XXX NEW ; XXX TODO --
  jp nz,number.return
  ld a,h
  or l
  jp nz,l53d8h
  ld a,$80 ; XXX OLD ; XXX TODO --
;;  dec a ; a=$FF ; XXX NEW ; XXX TODO --
  ld (negative_number_flags),a

l53d8h:
  call d_negate_
  ld a,(negative_number_flags)
  cp $80
  jp nz,number.return
  call pop_hl ; XXX TODO -- call drop instead?
  ld hl,$0000
  call push_hl

number.return:
  check "number.return"
  xor a
  ld (negative_number_flags),a
  ret

; --------------------------------------------------------------
  header space_,'space',0 ; {{{2

; doc{
;
; space ( -- )
;
; Display one space.
;
; }doc

  ld a,space_char
  jp print_a

; --------------------------------------------------------------
  header spaces_,'spaces',0 ; {{{2

; doc{
;
; spaces ( u -- )
;
; Display u spaces.
;
; Note:
;
; In fig-Forth, the parameter is an unsigned number (u), and the word's
; description is: "Type u spaces.".
;
; In Forth-83, the parameter is a positive number (+n) and the word's
; description is: "Displays +n ASCII spaces.  Nothing is displayed if +n is
; zero.".
;
; In ANS Forth the parameter is a signed number (n) and the word's
; description is: "If n is greater than zero, display n spaces.".
;
; Couplement Forth's `spaces` behaves like fig-Forth's. It's simpler and
; faster and 0..65535 spaces can be printed. When printing 0..32,767 spaces
; U uses an unsigned 16-bit number instead.
;
; }doc

  call pop_hl
  ld a,l
  or h
  ret z ; exit if no spaces
  ; XXX TODO -- this simple change make the word compatible with ANS Forth and Forth 83:
;;  bit 7,h
;;  ret nz ; exit if negative parameter

spaces.hl:
  push hl
  call space_
  pop hl
  ld a,h
  or l
  dec hl
  jp nz,spaces.hl
  ret

; --------------------------------------------------------------
  header emit_,'emit',0 ; {{{2

; doc{
;
; emit ( c -- )
;
; }doc

  call pop_hl
  ld a,l
print_a:
  rst $10
  ld a,$FF
  ld(sys_scr_ct),a ; no "scroll?" message
  ret

;  include "inc/emit.z80s" ; XXX TODO

; --------------------------------------------------------------
  header u_dot_,'u.',0 ; {{{2

; doc{
;
; u. ( u -- )
;
; }doc

  if data_stack_method = ix_dsm
    push ix
  else
    ld hl,(dsp)
    push hl
  endif
l54a3h:
  ld hl,(base) ; XXX ? -- why here?
  call push_hl ; XXX ? -- and here
  call slash_mod_
  call swap_
  ; XXX TODO -- pop_l or pop_a would be useful here
  call pop_hl ; XXX ? -- why not simply here?
  ld a,$09
  cp l
  jr c,l54cdh ; base >9?
  ld a,$30
l54b9h:
  add a,l
  ld l,a
  call push_hl
  call swap_
  call pop_hl
  ld a,h
  or l
  jr z,l54d1h
  call push_hl
  jp l54a3h
l54cdh:
  ld a,$37
  jp l54b9h
l54d1h:
  pop hl
  if data_stack_method = ix_dsm
    push ix
    pop de
  else
    ld de,(dsp)
  endif
  sbc hl,de
  srl l
  ld b,l
  inc b
l54dch:
  call pop_hl
  ld a,l
  push bc
  call print_a
  pop bc
  djnz l54dch
  jp space_

; --------------------------------------------------------------
  header slash_mod_,'/mod',0 ; {{{2

; doc{
;
; /mod ( n1 n2 -- n3 n4 )
;
; Divide the second single precision number on the stack by the top single
; precision number and leave the modulus (remainder) as second on the stack
; and the quotient on the top of the stack.
;
; }doc

  call pop_hl_de
de_hl_slash_mod:
  ex de,hl
  ld a,d
  or e
  jp z,division_by_zero_error
  and a
  ld b,d
  ld c,e
  ld de,$FFFF
de_hl_slash_mod.again:
  inc de
  sbc hl,bc
  jr nc,de_hl_slash_mod.again
  add hl,bc
  ex de,hl
  jp push_de_hl

; --------------------------------------------------------------
  header cls_,'cls',0 ; {{{2

; doc{
;
; cls ( -- )
;
; Clear the screen.
;
; }doc

  ; XXX TODO

  jp rom_cl_all

;  call rom_cl_all
;  ld a,2
;  jp rom_chan_open

; --------------------------------------------------------------
  header create_,'create',0 ; {{{2

; doc{
;
; create ( "name" -- )
;
; }doc

  ; XXX NEW -- it did nothing
  jp variable_

  ; XXX TODO -- create a word with this:
create_header:

  ; create a header with the name from the input stream

  ld de,(ip_fvar)
create_header.skip_blanks:
  inc de
  ld a,(de)
  cp space_char
  jr z,create_header.skip_blanks
  cp cr_char
  jp z,zero_length_name_error

  ld hl,(dp)
  ; hl=ffa of the new header
  ld (hl),0
  inc hl
  ; hl=lfa of the new header
  ld bc,(latest)
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ; hl=nfa of the new header

  push de ; start of the new word name
  ld b,$00 ; char counter
create_header.next_char:
  ld a,(de)
  cp space_char
  jr z,create_header.name_complete
  cp cr_char
  jr z,create_header.name_complete
  inc b
  inc de
  jp create_header.next_char

create_header.name_complete:
  ; (sp) = address of the first char of the name
  ; de = address of the last char of the name
  ; b = name length
  ; hl = nfa of the new header
  ld a,b
  ld (hl),a
  ld (latest),hl
  inc hl ; point to nfa+1 (name address) of the new header
  pop de ; address of the first char of the name

create_header.store_name:
  ; de = address of the first char of the name
  ; hl = nfa+1 (name address) of the new header
  ld a,(de)
  cp "A"
  jr c,create_header.store_char ; jump if lower than "A"
  cp "Z"+1
  jr nc,create_header.store_char ; jump if higher than "Z"
  or %100000 ; convert to lowercase
create_header.store_char
  ld (hl),a
  inc de
  inc hl
  djnz create_header.store_name

  ; hl = next free address in the dictionary,
  ;      and code field address of the new word
  ; de = address after the last char of the name

  ld (dp),hl
  dec de ; XXX ? -- why this?
  ld (ip_fvar),de
  ret

; --------------------------------------------------------------
  header compile_comma_,'compile,',0 ; {{{2

; doc{
;
; compile, ( xt -- ) "compile-comma"
;
; Append the execution semantics of the definition represented
; by _xt_ to the execution semantics of the current definition.
;
; ``compile,`` is the compilation equivalent of `execute`.
;
; }doc

  call pop_de
  jp compile_call_de

; --------------------------------------------------------------
  header invert_,'invert',0 ; {{{2

; doc{
;
; invert ( x1 -- x2 )
;
; Invert all bits of _x1_ giving its logical inverse _x2_.
;
; See: `0=`, `negate`.
;
; }doc

  ; Credit:
  ; Code adapted from Solo Forth, which adapted it from Z88 CamelForth.

  call pop_hl
  ld a,h
  cpl
  ld h,a
  ld a,l
  cpl
  ld l,a
  jp push_hl

; --------------------------------------------------------------
  header noop_,'noop',0 ; {{{2

; doc{
;
; noop ( <name> -- )
;
; }doc

  ret

; --------------------------------------------------------------
  header defer_,'defer',0 ; {{{2

; doc{
;
; defer ( <name> -- )
;
; }doc

  call create_header
  ld de,noop_
  call compile_jp_de
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header colon_,':',0 ; {{{2

; doc{
;
; : ( "name" -- )
;
; }doc

  ; XXX -- this check was useless:
;  ld a,(state)
;  and a ; compiling?
;  jp nz,compilation_only_error
  call right_bracket_
  call create_header
  ld l,colon_structure_id
  jp push_hl

; --------------------------------------------------------------
  header semicolon_,';',immediate+compile_only ; {{{2

; doc{
;
; ; ( colon-sys -- ) ; XXX TODO -- stack
;
; }doc

  call pop_hl
  ld a,colon_structure_id
  cp l
  jp nz,not_found_error ; XXX ? -- why this error message?
  ld hl,(dp)
  ld (hl),$C9 ; Z80 ret
  inc hl
  ld (dp),hl
  call left_bracket_
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header cr_,'cr',0 ; {{{2

; doc{
;
; cr ( -- )
;
; }doc

  ld a,$0D
  jp print_a

; --------------------------------------------------------------
  header words_,'words',0 ; {{{2

; doc{
;
; words ( -- )
;
; List all the words in the context dictionary.
;
; }doc

  ; XXX TODO -- print word info

  check "in words!"

  ld hl,(latest)
words.print_word:
  ; hl = nfa
  push hl
  ld b,$00
  ld c,(hl)
  inc hl
  call print_bc_chars_at_hl
  call space_
  pop hl ; hl = nfa
  dec hl ; hl = lfa+1
  ld a,(hl)
  dec hl ; hl = lfa
  ld l,(hl)
  ld h,a
  ; hl = nfa of previous word or zero if end of dictionary
  or l ; end of dictionary?
  jr nz,words.print_word ; no
  ret

; --------------------------------------------------------------
  header base_,'base',0 ; {{{2

; doc{
;
; base ( n -- )
;
; }doc

  call do_variable
base: ; current number base
  dw $000A

; --------------------------------------------------------------
  header rp0_,'rp0',0 ; {{{2

; doc{
;
; rp0 ( -- a )
;
; }doc

  ld hl,rp0
  jp push_hl
rp0: ; initial value of the return stack pointer
  dw return_stack_bottom

; --------------------------------------------------------------
  header rp_fetch_,'rp@',0 ; {{{2

; doc{
;
; rp@ ( -- a )
;
; }doc

  ld ($+5),sp
  ld hl,0
  jp push_hl

; --------------------------------------------------------------
  header rp_store_,'rp!',0 ; {{{2

; doc{
;
; rp! ( a -- )
;
; }doc

  jp pop_hl
  di
  ld sp,hl
  ei
  ret

; --------------------------------------------------------------
  header sp0_,'sp0',0 ; {{{2

; doc{
;
; sp0 ( -- a )
;
; }doc

  call do_constant
sp0:
  dw data_stack_bottom

; --------------------------------------------------------------
  header sp_fetch_,'sp@',0 ; {{{2

; doc{
;
; sp@ ( -- a )
;
; }doc

if data_stack_method = ix_dsm

  push ix
  pop hl

else

dsp: equ $+1 ; data stack pointer
  ld hl,data_stack_bottom

endif

  jp push_hl

; --------------------------------------------------------------
  header sp_store_,'sp!',0 ; {{{2

; doc{
;
; sp! ( a -- )
;
; }doc

  call pop_hl
  if data_stack_method = ix_dsm
    ; XXX TODO -- improve with direct fetch of _a_
    push hl
    pop ix
  else
    ld (dsp),hl
  endif
  ret

; --------------------------------------------------------------
  header decimal_,'decimal',0 ; {{{2

; doc{
;
; decimal ( -- )
;
; }doc

  ld a,$0A
  ld (base),a
  ret

; --------------------------------------------------------------
  header hex_,'hex',0 ; {{{2

; doc{
;
; hex ( -- )
;
; }doc

  ld a,$10
  ld (base),a
  ret

; --------------------------------------------------------------
  header c_comma_,'c,',0 ; {{{2

; doc{
;
; c, ( c -- )
;
; }doc

  call pop_de
  ld hl,(dp)
  ld (hl),e
  inc hl
  ld (dp),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header comma_,',',0 ; {{{2

; doc{
;
; , ( x -- )
;
; }doc

  call pop_de
  call compile_de
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header allot_,'allot',0 ; {{{2

; doc{
;
; allot ( n -- )
;
; }doc

  call pop_hl
  ld de,(dp)
  add hl,de
  ld (dp),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header store_,'!',0 ; {{{2

; doc{
;
; ! ( x a -- )
;
; }doc

  call pop_hl_de
  ld (hl),e
  inc hl
  ld (hl),d
  ret

; --------------------------------------------------------------
  header c_store_,'c!',0 ; {{{2

; doc{
;
; c! ( c a -- )
;
; }doc

  call pop_hl_de
  ld (hl),e
  ret

; --------------------------------------------------------------
  header fetch_,'@',0 ; {{{2

; doc{
;
; @ ( a -- x )
;
; }doc

  call pop_hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  jp push_de

; --------------------------------------------------------------
  header c_fetch_,'c@',0 ; {{{2

; doc{
;
; c@ ( ca -- c )
;
; }doc

  call pop_hl
  ld l,(hl)
  ld h,$00
  jp push_hl

; --------------------------------------------------------------
  header on_,'on',0 ; {{{2

; doc{
;
; on ( a -- )
;
; }doc

  call pop_hl
  ld (hl),true
  ret

; --------------------------------------------------------------
  header off_,'off',0 ; {{{2

; doc{
;
; off ( a -- )
;
; }doc

  call pop_hl
  ld (hl),false
  ret

; --------------------------------------------------------------
  header dp_,'dp',0 ; {{{2

; doc{
;
; dp ( -- a )
;
; Return the address of the dictionary pointer variable, which contains the
; next free memory location above the dictionary. The value may be read by
; `here` and altered by `allot`.
;
; }doc

  call do_variable
dp:
  dw end_of_code

; --------------------------------------------------------------
  header here_,'here',0 ; {{{2

; doc{
;
; here ( -- a )
;
; Return the content of `dp`, the address of the next available memory
; location above the dictionary.
;
; }doc

  ld hl,(dp)
  jp push_hl

; --------------------------------------------------------------
  header latest_,'latest',0 ; {{{2

; doc{
;
; latest ( -- nfa )
;
; Return the name field address of the last word defined in the `current`
; vocabulary.
;
; }doc

; XXX TODO -- `current` is not implemented yet ; {{{2

latest: equ $+1
  ld hl,current_latest ; nfa of the latest Forth word in the dictionary
  jp push_hl

; --------------------------------------------------------------
  header semicolon_code_,';code',immediate ; {{{2

; doc{
;
; ;code ( colon-sys -- ) ; XXX TODO -- stack
;
; }doc

  ; XXX TODO adapt, test

  call pop_hl
  ld a,colon_structure_id
  cp l
  jr z,l56cch
  ld (pairs_fvar),a
  call push_hl
  jp semicolon.end
l56cch:
  xor a
  ld (pairs_fvar),a
semicolon.end:
  call left_bracket_
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header code_colon_,'code:',immediate ; {{{2

; doc{
;
; code: ( -- )
;
; }doc

  ; XXX TODO adapt, test

  call right_bracket_
  ld a,(pairs_fvar)
  and a
  ret nz
  ld l,colon_structure_id
  jp push_hl

; --------------------------------------------------------------
  header in_,'in',0 ; {{{2

; doc{
;
; in ( a -- c )
;
; }doc

  call pop_hl
  ld b,h
  ld c,l
  in a,(c)
  ld l,a
  ld h,$00
  jp push_hl

; --------------------------------------------------------------
  header out_,'out',0 ; {{{2

; doc{
;
; out ( a c -- )
;
; }doc

  call pop_hl_de
  ld b,h
  ld c,l
  out (c),e
  ret

; --------------------------------------------------------------
  header page_,'page',0 ; {{{2

; doc{
;
; page ( -- )
;
; On a terminal, clear the screen and resets the cursor position to the
; upper left corner.  On a printer perform a form feed.
;
; }doc

linked_stream: equ $+1 ; XXX TODO make it a variable
  ld a,$00
  cp $03 ; printing?
  jp nz,cls_
  ; printing
  ld a,form_feed_char
  jp print_a

; --------------------------------------------------------------
  header do_,'do',immediate+compile_only ; {{{2

; doc{
;
; do ( -- do-sys ) ; XXX TODO -- stack
;
; }doc

  ld de,do_do
  call compile_call_de
  ; hl = dp
  call push_hl ; save the address `loop` must jump to
  ld l,do_structure_id
  jp push_hl ; XXX TODO -- push_a?

  ; XXX TODO -- factor to a word (`(do)`?)
do_do:
  pop bc
  call pop_hl_de
  push hl
  push de
  push bc
  ret

l574fh:
  pop hl
  pop de
  pop bc
  push hl
  push bc
  ld a,$80
  xor d
  ld d,a
  call pop_hl
  ld b,h
  ld c,l
  pop hl
  add hl,bc
  rl b
  push af
  ld b,h
  ld c,l
  ld a,$80
  xor h
  ld h,a
  pop af
  jr c,l5772h
  and a
  sbc hl,de
  jr c,l5779h
  jp l5785h

l5772h:
  and a
  sbc hl,de
  jr c,l5785h
  jr z,l5785h

l5779h:
  pop hl
  push bc
  ld a,$80
  xor d
  ld d,a
  push de
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ret

l5785h:
  pop hl
  inc hl
  inc hl
  jp (hl)

l5789h:
  pop de
  pop hl
  pop bc
  inc bc
  push hl
  and a
  sbc hl,bc
  jr z,l62e0h
  pop hl
  push bc
  push hl
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ret

l62e0h:
  pop bc
  ex de,hl
  inc hl
  inc hl
  jp (hl)

; --------------------------------------------------------------
  header plus_loop_,'+loop',immediate+compile_only ; {{{2

; doc{
;
; +loop ( do-sys - ) ; XXX TODO -- stack
;
; }doc

  ld a,do_structure_id
  call structured
  ld de,l574fh
  call compile_call_de
  ; hl = dp
  jp sub_57a3h

sub_57a3h:
  call pop_hl
  ld b,h
  ld c,l
  ld hl,(dp)
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  header loop_,'loop',immediate+compile_only ; {{{2

; doc{
;
; loop ( do-sys -- ) ; XXX TODO -- stack
;
; }doc

  ld a,do_structure_id
  call structured
  ld de,l5789h
  call compile_call_de
  ; hl = dp
  jp sub_57a3h

; --------------------------------------------------------------
  header j_,'j',0 ; {{{2

; doc{
;
; j ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
;
; Return a copy of the index of the next outer loop.  May only
; be used within a nested `do`-`loop` or `do`-`+loop` structure.
;
; }doc

  ld hl,$000A
  add hl,sp
  ld a,(hl)
  inc hl
  ld l,(hl)
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  header i_,'i',0 ; {{{2

; doc{
;
; i ( -- n|u ) ( R: loop-sys -- loop-sys )
;
; Return a copy of the current (innermost) loop index. May only
; be used within a nested `do`-`loop` or `do`-`+loop` structure.
;
; }doc

  ld hl,$0004
  add hl,sp
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  jp push_hl

; --------------------------------------------------------------
  header link_,'link',0 ; {{{2

; doc{
;
; link ( n -- )
;
; }doc

  ; XXX TODO adapt

  call pop_hl
  ld a,l
link.a:
;;  cp $03
;;  jr nz,link.other_than_3
;;  ; stream = 3
;; XXX OLD:
;;  set 7,(iy+$00)
;;  jp link.do
;;  ; link to channel p
;;link.other_than_3:
;;  ; stream <> 3
;; XXX OLD:
;;  res 7,(iy+$00)
;;  xor a
;; link.do:

  ld (linked_stream),a ; XXX NEW
  jp rom_chan_open

; --------------------------------------------------------------
  header home_,'home',0 ; {{{2

; doc{
;
; home ( -- )
;
; Make the next character displayed will appear in column 0, row 0 of the
; user output device, the upper left corner.
;
; }doc

  ld a,at_char
  call print_a
  ld e,0
  ld l,0
  jr at_xy_.el

; --------------------------------------------------------------
  header at_xy_,'at-xy',0 ; {{{2

; doc{
;
; at-xy ( u1 u2 -- )
;
; Make the next character displayed will appear in column u1, row u2 of the
; user output device, the upper left corner of which is column zero, row
; zero.
; Note: In Couplement Forth, the upper bytes of the parameters are ignored.
;
; }doc

  ld a,at_char
  call print_a
  call pop_hl_de
at_xy_.el  
  push de
  ld a,l
  call print_a
  pop de
  ld a,e
  jp print_a

; --------------------------------------------------------------
  header border_,'border',0 ; {{{2

; doc{
;
; border ( u -- )
;
; Set the border of the screen to color to _n_.  Only the 3
; lower bits of _n_ are used (for colors 0 .. 7).
;
; }doc

  call pop_hl
  ld a,l
border.a:
  and %00000111 ; force value 0 .. 7
  jp $229B ; secondary entry point in the "BORDER" ROM routine

; --------------------------------------------------------------
  header beep_,'beep',0 ; {{{2

; doc{
;
; beep ( u1 u2 -- )
;
; }doc

  ; XXX TODO
  ret

; --------------------------------------------------------------
  header dot_quote_,'."',immediate+compile_only ; {{{2

; doc{
;
; ." ( "ccc<quote>" -- )
;
; }doc

  ; XXX TODO -- Rewrite with a porsing word.

  ld de,l582bh
  call compile_call_de
  ; hl = dp
  ld de,(ip_fvar)
  inc de
l5812h:
  inc de
  ld a,(de)
  cp $22
  jr z,l5820h
  cp $0D
  jr z,l5820h
  ld (hl),a
  inc hl
  jp l5812h
l5820h:
  ld (hl),$FF
  inc hl
  ld (dp),hl
  ld (ip_fvar),de
  ret

l582bh:
  pop hl
l582ch:
  ld a,(hl)
  cp $FF
  jr z,l5837h
  call print_a
  inc hl
  jp l582ch
l5837h:
  inc hl
  jp (hl)

; --------------------------------------------------------------
  header star_,'*',0 ; {{{2

; doc{
;
; * ( n1 n2 -- n3 )
;
; }doc

  call u_mult_ ; XXX TODO -- `u*`?
  jp pop_hl

; --------------------------------------------------------------
  header type_,'type',0 ; {{{2

; doc{
;
; type ( ca len -- )
;
; }doc

  call pop_hl_de
  ex de,hl
  ld b,d
  ld c,e
  jp print_bc_chars_at_hl

; --------------------------------------------------------------
  header bye_,'bye',0 ; {{{2

; doc{
;
; bye ( -- )
;
; }doc

saved_basic_sp: equ $+1 ; Sinclair BASIC's stack pointer
  ld hl,0
  ld sp,hl
  rst $08     ; error
  db $FF      ; 0: "OK"

; --------------------------------------------------------------
  header return_,'return',0 ; {{{2

; doc{
;
; return ( n -- )
;
; Return to BASIC with return code _n_.
; The return code is used as line number for disk operations.
;
; }doc

  call pop_hl
return.hl:
  ld b,h
  ld c,l
return.bc:
  ld sp,(saved_basic_sp)
  ret

return.a:
  ; Return to BASIC with register A as return code.
  ld b,0
  ld c,a
  jr return.bc

; --------------------------------------------------------------
  header dir_,'dir',0 ; {{{2

; doc{
;
; dir ( -- )
;
; }doc

  ld a,$03 ; dir id
  jp return.a

; --------------------------------------------------------------
  header equals_,'=',0 ; {{{2

; doc{
;
; = ( n1 n2 -- f )
;
; }doc

  call pop_hl_de
  if size_optimization
    call compare_de_hl_unsigned ; XXX FIXME -- unsigned?
    jp z,true_
    jp false_
  else
    ld a,l  ; 09 T
    cp e    ; 04 T
    jp nz,false_
    ld a,h  ; 09 T
    cp d    ; 09 T
    jp nz,false_
    jp true_
  endif

; --------------------------------------------------------------
  header not_equals_,'<>',0 ; {{{2

; doc{
;
; <> ( n1 n2 -- f )
;
; }doc

  call pop_hl_de
  if size_optimization
    call compare_de_hl_unsigned ; XXX FIXME -- unsigned?
    jp z,false_
    jp true_
  else
    ld a,l  ; 09 T
    cp e    ; 04 T
    jp nz,true_
    ld a,h  ; 09 T
    cp d    ; 09 T
    jp nz,true_
    jp false_
  endif

; --------------------------------------------------------------
  header slash_,'/',0 ; {{{2

; doc{
;
; / ( n1 n2 -- n3 )
;
; }doc

  call slash_mod_
  call swap_
  jp pop_hl

; --------------------------------------------------------------
  header mod_,'mod',0 ; {{{2

; doc{
;
; mod ( n1 n2 -- n3 )
;
; }doc

  call slash_mod_
  jp pop_hl

; --------------------------------------------------------------
  header begin_,'begin',immediate+compile_only ; {{{2

; doc{
;
; begin ( -- begin-sys ) ; XXX TODO -- stack
;
; }doc

  ld hl,(dp)
  call push_hl
  ld l,begin_structure_id
  jp push_hl

; --------------------------------------------------------------
  header until_,'until',immediate+compile_only ; {{{2

; doc{
;
; until ( begin-sys -- )
;
; }doc

  ld a,begin_structure_id
  call structured
  ld de,zero_branch_
  call compile_call_de
  ; hl = dp
  jp sub_57a3h

; --------------------------------------------------------------
  header less_than_,'<',0 ; {{{2

; doc{
;
; < ( n1 n2 -- f )
;
; }doc

  call pop_hl_de
  ex de,hl
  ld a,d
  xor h
  bit 7,a
  jr nz,l5a4fh
  sbc hl,de
l5a4fh:
  bit 7,h
  jp z,false_
  jp true_

; --------------------------------------------------------------
  header greater_than_,'>',0 ; {{{2

; doc{
;
; > ( n1 n2 -- f )
;
; }doc

  ; XXX TODO -- direct version, no swap
  call swap_
  jp less_than_

; --------------------------------------------------------------
  header u_less_than_,'u<',0

; doc{
;
; u< ( u1 u2 -- f )
;
; }doc

  call pop_hl_de
  ex de,hl
  call compare_de_hl_unsigned
  jp c,true_
  jp false_

compare_de_hl_unsigned:
  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de
  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

; --------------------------------------------------------------
  header r_drop_,'rdrop',0 ; {{{2

; doc{
;
; rdrop ( -- ) ( R: x -- )
;
; }doc

  pop hl
  pop de
  jp (hl)

; --------------------------------------------------------------
  header r_fetch_,'r@',0 ; {{{2

; doc{
;
; r@ ( -- x ) ( R: x --  )
;
; }doc

  pop hl
  push hl
  jp push_hl

; --------------------------------------------------------------
  header r_from_,'r>',0 ; {{{2

; doc{
;
; r> ( -- x ) ( R: x -- )
;
; }doc

  pop hl
  pop de
  call push_de
  jp (hl)

; --------------------------------------------------------------
  header to_r_,'>r',0 ; {{{2

; doc{
;
; >r ( x -- ) ( R: -- x )
;
; }doc

  call pop_de
  pop hl
  push de
  jp (hl)

; --------------------------------------------------------------
  header key_question_,'key?',0 ; {{{2

; doc{
;
; key? ( -- f )
;
; }doc

  ; XXX TODO

  jp true_ ; XXX TMP

  if 0

  ld a,(sys_last_k)
  ld (previous_key),a
key_question.1
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key?
  jp z,key.1
  ld l,a ; save the key
  xor a
  ld (sys_last_k),a ; delete the last key
  ld h,0
  jp push_hl

  ; XXX TODO see the code of Couplement Forth

  endif

; --------------------------------------------------------------
  header key_,'key',0 ; {{{2

; doc{
;
; key ( -- c )
;
; }doc

  ; XXX TODO call `key?`
  ld a,(sys_last_k)
  ld (previous_key),a
key_.wait
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key?
  jp z,key_.wait
  ld l,a ; save the key
  xor a
  ld (sys_last_k),a ; delete the last key
  ld h,0
  jp push_hl

; --------------------------------------------------------------
  header over_,'over',0 ; {{{2

; doc{
;
; over ( x1 x2 -- x1 x2 x1 )
;
; }doc

  call pop_hl_de
  call push_de_hl
  jp push_de

; --------------------------------------------------------------
  header rot_,'rot',0 ; {{{2

; doc{
;
; rot ( x1 x2 x3 -- x2 x3 x1 )
;
; }doc

  call pop_hl_de
  ld b,h
  ld c,l
  call pop_hl
  push hl
  ld h,b
  ld l,c
  call push_de_hl
  pop hl
  jp push_hl

; --------------------------------------------------------------
  header two_dup_,'2dup',0 ; {{{2

; doc{
;
; 2dup ( x1 x2 -- x1 x2 x1 x2 )
;
; }doc

  call pop_hl_de
  call push_de_hl
  jp push_de_hl

; --------------------------------------------------------------
  header pad_,'pad',0 ; {{{2

; doc{
;
; pad ( -- a )
;
; Places the address of the pad on the top of the stack. See the definition
; of INPUT under NUMBER.
;
; }doc

pad_address: equ $+1
  ld hl,pad_start ; XXX TODO -- rename
  jp push_hl

; --------------------------------------------------------------
  header tib_,'tib',0 ; {{{2

; doc{
;
; tib ( -- a )
;
; }doc

tib_address: equ $+1 ; start address of the Terminal Input Buffer
  ld hl,tib_start ; XXX TODO -- understand why originally it's tib_end; tib_start works too, if etib_fvar is set to tib_start
  jp push_hl

; XXX TODO
;to_in_lfa:
;  dw pad_name
;to_in_nfa:
;  db $03
;to_in_name:
;  db ">in"
;to_in_:
;  ld hl,to_in
;  jp push_hl
;to_in:
;  dw $0000 ; character offset within the input stream

; --------------------------------------------------------------
  header query_,'query',0 ; {{{2

; doc{
;
; query ( -- )
;
; Clear the input buffer and accept character input until RETURN is
; pressed.  It can be edited in the normal way.
;
; }doc

  ; XXX TODO -- simplify, standardize
  ld hl,(tib_address)
  push hl
  ld hl,(pad_address)
  inc hl
  ld (tib_address),hl
  call keyboard_input
  pop hl
  ld (tib_address),hl
  ret

; --------------------------------------------------------------
  header retype_,'retype',0 ; {{{2

; doc{
;
; retype ( -- )
;
; This is similar to QUERY but does not clear the input buffer enabling the
; text to be edited. Move the text into PAD starting at the second address
; of PAD before calling RETYPE.
;
; }doc

  ; XXX TODO -- simplify, standardize
  ld hl,(tib_address)
  push hl
  ld hl,(pad_address)
  inc hl
  ld (tib_address),hl
  call keyboard_input.next_key
  pop hl
  ld (tib_address),hl
  ret

; --------------------------------------------------------------
  header minus_cursor_,'-cursor',0 ; {{{2

; doc{
;
; -cursor ( n -- ) ; XXX NEW
;
; Delete the cursor.
;
; }doc

  call space_
  call c_lit_
  db left_char
  jp emit_

; --------------------------------------------------------------
  header backspaces_,'backspaces',0 ; {{{2

; doc{
;
; backspaces ( +n -- )
;
; Delete +n chars at the left of the cursor.
;
; }doc

  call c_lit_
  db left_char
  call dup_
  call emit_
  call space_
  call emit_
  call one_minus_
  call dup_
  call zero_equals_ ; XXX TODO --
  call zero_branch_ ; XXX TODO -- improve with `?branch`
  dw backspaces_
  jp drop_

; --------------------------------------------------------------
  header paren_accept_control_char_,'(accept-control-char)',0 ; {{{2

; doc{
;
; (accept-control-char) ( ca len len2 c -- ca len len2' )
;
; }doc

  border 2 ; XXX INFORMER
  ; check the delete key
  call dup_
  call c_lit_
  db delete_char
  call equals_ ; delete?
  call zero_branch_
  dw paren_accept_control_char.edit
  ; delete the last char
  call drop_ ; c
  call dup_ ; something to delete?
  call zero_branch_
  dw paren_accept_control_char.end
  ; do it
  call minus_cursor_
  call one_minus_
  call one_
  jp backspaces_

paren_accept_control_char.edit:
  ; check the edit key
  call c_lit_
  db edit_char
  call equals_ ; edit?
  call zero_branch_
  dw paren_accept_control_char.end
  ; delete the whole input
  call dup_ ; something to delete?
  call zero_branch_
  dw paren_accept_control_char.end
  ; do it
  call minus_cursor_
  call zero_
  call swap_
  call backspaces_

paren_accept_control_char.end:
  ret

; --------------------------------------------------------------
  header paren_accept_ascii_char_,'(accept-ascii-char)',0 ; {{{2

; doc{
;
; (accept-ascii-char) ( ca len len2 c -- ca len len2' )
;
; }doc

  border 4 ; XXX INFORMER
  call to_r_
  call two_dup_
  call minus_
  call r_from_
  call swap_ ; space left
  call zero_branch_
  dw paren_accept_ascii_char.no

  ; there's space left for the char
  call dup_
  call emit_
  call over_
  call c_lit_
  db 4
  call pick_
  call plus_
  call c_store_
  jp one_plus_

paren_accept_ascii_char.no:
  ; no space left for the char
  jp drop_

; --------------------------------------------------------------
  header paren_accept_key_,'(accept-key)',0 ; {{{2

; doc{
;
; (accept-key) ( ca len len2 c -- ca len len2' )
;
; }doc

  call dup_
  call bl_
  call c_lit_
  db 127
  if false
    ; XXX FIXME
    call within_ ; ASCII?
  else
    call over_
    call minus_
    call to_r_
    call minus_
    call r_from_
    call u_less_than_
  endif
  call zero_branch_
  dw paren_accept_control_char_ ; not ASCII
  jp paren_accept_ascii_char_ ; ASCII

; --------------------------------------------------------------
  header paren_accept_,'(accept)',0 ; {{{2

; doc{
;
; (accept) ( ca len -- len2 )
;
; }doc

  call zero_ ; len2
paren_accept.begin:
  call c_lit_
  db 143 ; XXX TMP cursor
  call emit_
  call c_lit_
  db bs_char
  call emit_
  call key_
  call dup_
  call c_lit_
  db cr_char
  call equals_  ; return?
  call zero_branch_
  dw paren_accept_key_ ; no
  ; the return key was pressed
  call minus_cursor_
  call space_
  call drop_
  call nip_
  jp nip_

; --------------------------------------------------------------
  header accept_,'accept',0 ; {{{2

; doc{
;
; accept ( ca +n1 -- +n2 )
;
; }doc

  jp paren_accept_

; --------------------------------------------------------------
  header word_,'word',0 ; {{{2

; doc{
;
; word ( char "<chars>ccc<char>" -- c-addr )
;
; XXX TODO -- edit the following ANS description:
;
; Skip leading delimiters.  Parse characters ccc delimited by char.  An
; ambiguous condition exists if the length of the parsed string is greater
; than the implementation-defined length of a counted string.
;
; c-addr is the address of a transient region containing the parsed word as
; a counted string.  If the parse area was empty or contained no characters
; other than the delimiter, the resulting string has a zero length.  A
; space, not included in the length, follows the string.  A program may
; replace characters within the string.
;
; Note: The requirement to follow the string with a space is obsolescent and
; is included as a concession to existing programs that use CONVERT.  A
; program shall not depend on the existence of the space.
;
; }doc

  ; XXX TODO -- test; it has been rewritten after ANS
  call pop_hl
  ld a,l
  ld hl,(ip_fvar)
word.skip_leading_delimiter:
  inc hl
  cp (hl)
  jp z,word.skip_leading_delimiter
  ; hl=address of the first valid char to parse
  push hl
  ld bc,$0000 ; char count
word.parse:
  inc c
  inc hl
  cp (hl)
  jr nz,word.parse
  ; trailing delimiter found
  ; bc = length of the parsed text (0-255)
  ld hl,(pad_address) ; destination
  ld a,c
  ld (hl),a
  inc hl
  pop de ; origin
  ex de,hl
  ldir ; move the text
  ld (ip_fvar),hl
  ld hl,(pad_address)
  jp push_hl

; --------------------------------------------------------------
  header if_,'if',immediate+compile_only ; {{{2

; doc{
;
; if ( -- if-sys ) ; XXX TODO -- stack
;
; }doc

  ld de,zero_branch_
  call compile_call_de
  ; hl = dp
  call push_hl ; save the address of the jump address
  inc hl
  inc hl
  ld (dp),hl ; skip it
  ld l,if_structure_id
  jp push_hl ; XXX TODO -- push_a?

; --------------------------------------------------------------
  header else_,'else',immediate+compile_only ; {{{2

; doc{
;
; else ( if-sys -- if-sys ) ; XXX TODO -- stack
;
; }doc

  ld a,if_structure_id
  call structured
  ld de,branch_
  call compile_call_de
  ; hl = dp
  push hl
  inc hl
  inc hl
  ld (dp),hl
  call pop_hl
  ld bc,(dp)
  ld (hl),c
  inc hl
  ld (hl),b
  pop hl
  call push_hl
  ld l,if_structure_id
  jp push_hl

; --------------------------------------------------------------
  header then_,'then',immediate+compile_only ; {{{2

; doc{
;
; then ( if-sys -- ) ; XXX TODO -- stack
;
; }doc

  ld a,if_structure_id
  call structured
  call pop_hl
  ld bc,(dp)
  ld (hl),c
  inc hl
  ld (hl),b
  ret

; --------------------------------------------------------------
  header builds_,'<builds',compile_only ; {{{2

; doc{
;
; <builds ( "name" -- ) ; XXX TODO -- stack
;
; }doc

  ; XXX TODO -- remove, adapt
  ld de,create_header
  call compile_call_de
  ; hl = dp
  ld (hl),$11
  inc hl
  call push_hl
  inc hl
  inc hl
  ld (dp),hl
  ld de,compile_call_de
  call compile_call_de
  ; hl = dp
  ld (hl),$36
  inc hl
  ld (hl),$C9  ; Z80 "ret"
  inc hl
  ld (hl),$23
  inc hl
  ld (hl),$22
  inc hl
  ld bc,dp
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ld l,builds_structure_id
  jp push_hl

; --------------------------------------------------------------
  header does_,'does>',immediate+compile_only ; {{{2

; doc{
;
; does> ( -- ) ; XXX TODO -- stack
;
; }doc

  ld a,builds_structure_id
  call structured
  ld hl,(dp)
  ld (hl),$C9  ; Z80 "ret"
  inc hl
  ld (dp),hl
  ld d,h
  ld e,l
  call pop_hl
  ld (hl),e
  inc hl
  ld (hl),d
  ld hl,(dp)
  ld (hl),$E1  ; Z80 "pop hl"
  inc hl
  ld (hl),$E5  ; Z80 "push hl"
  inc hl
  ld (hl),$23  ; Z80 "inc hl"
  inc hl
  ld (hl),$CD  ; Z80 "call...
  inc hl
  ld bc,push_hl
  ld (hl),c
  inc hl
  ld (hl),b     ; Z80 ...address"
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  header while_,'while',immediate+compile_only ; {{{2

; doc{
;
; while ( begin-sys -- begin-sys ) ; XXX TODO -- stack
;
; }doc

  ld a,begin_structure_id
  call structured
  ld de,zero_branch_
  call compile_call_de
  ; hl = dp
  call push_hl
  inc hl
  inc hl
  ld (dp),hl
  ld l,begin_structure_id
  jp push_hl

; --------------------------------------------------------------
  header repeat_,'repeat',immediate+compile_only ; {{{2

; doc{
;
; repeat ( begin-sys -- ) ; XXX TODO -- stack
;
; }doc

  ld a,begin_structure_id
  call structured
  ld de,branch_
  call compile_call_de
  ; hl = dp
  push hl
  inc hl
  inc hl
  ld (dp),hl
  ld b,h
  ld c,l
  call pop_hl
  ld (hl),c
  inc hl
  ld (hl),b
  call pop_hl
  ld b,h
  ld c,l
  pop hl
  ld (hl),c
  inc hl
  ld (hl),b
  ret

; --------------------------------------------------------------
  header variable_,'variable',0 ; {{{2

; doc{
;
; variable ( -- a )
;
; }doc

  call create_header
  ld de,do_variable
  call compile_call_de
  ; hl = dp
  inc hl
  inc hl ; point to the address after the value
  ld (dp),hl
  jp save_dictionary_pointers

; XXX TODO create word `(variable)` or `do_variable` and call to its cfa
do_variable:
  pop hl ; get the return address
  jp push_hl

; --------------------------------------------------------------
  header constant_,'constant',0 ; {{{2

; doc{
;
; constant ( -- x )
;
; }doc

  call create_header
  ld de,do_constant
  call compile_call_de
  call pop_de
  ld hl,(dp)
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  ld (dp),hl
  jp save_dictionary_pointers

; XXX TODO create word `(constant)` or `do_constant` and call to its cfa
do_constant:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  jp push_de

; --------------------------------------------------------------
  header dot_,'.',0 ; {{{2

; doc{
;
; . ( n -- )
;
; }doc

  ; XXX TODO -- 2020-05-27: make standard, factor, rewrite

  call pop_hl
  bit 7,h ; negative?
  jr z,dot_code_field.do
  ; negative number
  ex de,hl
  ld hl,$0000
  sbc hl,de
  ld a,"-"
  push hl
  call print_a
  pop hl
dot_code_field.do:
  call push_hl
  jp u_dot_

; --------------------------------------------------------------
  header cmove_,'cmove',0 ; {{{2

; doc{
;
; cmove ( ca1 ca2 len -- )
;
; }doc

  call pop_hl
  ld a,h
  or l ; something to move?
  jr z,cmove.end ; nothing
  ld b,h
  ld c,l
  call pop_hl_de
  ex de,hl
  ldir
  ret
cmove.end:
  jp pop_hl_de

; --------------------------------------------------------------
  header and_,'and',0 ; {{{2

; doc{
;
; and ( x1 x2 -- x3 )
;
; }doc

  call pop_hl_de
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  header or_,'or',0 ; {{{2

; doc{
;
; or ( x1 x2 -- x3 )
;
; }doc

  call pop_hl_de
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  header xor_,'xor',0 ; {{{2

; doc{
;
; xor ( x1 x2 -- x3 )
;
; }doc

  call pop_hl_de
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp push_hl

; --------------------------------------------------------------
  header false_,'false',0 ; {{{2

; doc{
;
; false ( -- false )
;
; }doc

  ld hl,false
  jp push_hl

; --------------------------------------------------------------
  header true_,'true',0 ; {{{2

; doc{
;
; true ( -- true )
;
; }doc

  ld hl,true
  jp push_hl

; --------------------------------------------------------------
  header zero_,'0',0 ; {{{2

; doc{
;
; 0 ( -- 0 )
;
; }doc

  ld hl,0
  jp push_hl

; --------------------------------------------------------------
  header one_,'1',0 ; {{{2

; doc{
;
; 1 ( -- 1 )
;
; }doc

  ld hl,1
  jp push_hl

; --------------------------------------------------------------
  header bl_,'bl',0 ; {{{2

; doc{
;
; bl ( -- c )

  ld hl,space_char
  jp push_hl

; --------------------------------------------------------------
  header count_,'count',0 ; {{{2

; doc{
;
; count ( a -- a' u )

  call pop_hl
  ld a,(hl)
  inc hl
  call push_hl
  ld h,0
  ld l,a
  jp push_hl

; --------------------------------------------------------------
  header find_,'find',0 ; {{{2

; doc{
;
; find ( "name" -- cfa )
;
; }doc

  ; XXX TODO -- rewrite according to ANS; now it simply skips leading blanks!
  ; XXX TODO -- move this code to `(find)`
  ld de,(ip_fvar)
  find.skip_blank:
  inc de
  ld a,(de)
  cp space_char
  jp z,find.skip_blank
  cp cr_char
  jp z,find.skip_blank
  ld (ip_fvar),de

  ld b,10 ; XXX TMP --- debugging
  check "Name in find:"
  check.string.de_b

  jp paren_find_

; --------------------------------------------------------------
  header paren_abort_,'(abort)',0 ; {{{2

; doc{
;
; (abort) ( i*x -- ) ( R: j*x -- )
;
; Empty the data stack and perform the function of `quit`, which includes
; emptying the return stack, without displaying a message.
;
; }doc

  ; XXX TODO -- test, confirm
  call init_data_stack
  jp quit_

; --------------------------------------------------------------
  header abort_,'abort',0 ; {{{2

; doc{
;
; abort ( i*x -- ) ( R: j*x -- )
;
; Empty the data stack and perform the function of QUIT, which includes
; emptying the return stack, without displaying a message.
;
; }doc

  ; XXX NEW -- 2013-02-02
  ; XXX TODO -- test, confirm
  ; XXX TODO -- improve with the exception extension set
  jp paren_abort_

; --------------------------------------------------------------
  header cold_,'cold',0 ; {{{2

; doc{
;
; cold ( -- )
;
; The cold start procedure.  Adjust the dictionary pointer to the minimum
; standard and restart via `abort`.  May be called from terminal to remove
; the application program and restart.
;
; }doc

cold_latest: equ $+1 ; nfa of the last Forth word in dictionary at cold start
  ld hl,current_latest
  ld (latest),hl
cold_dp: equ $+1 ; next vacant address in dictionary at cold start
  ld hl,end_of_code
  ld (dp),hl
  ld (fence),hl
  call save_dictionary_pointers
  call left_bracket_
  call page_
  call bootmessage_
  ; XXX NOTE -- 2013-02-02 quit_ changed to abort_, after FIG-Forth.
  jp abort_

; --------------------------------------------------------------
  header fence_,'fence',0 ; {{{2

; doc{
;
; fence ( -- a )
;
; Return an address which contains the address below which `forget` will not operate.
;
; }doc

  ld hl,fence
  jp push_hl
  fence:
  dw end_of_code ; address below which `forget` will not operate.

; --------------------------------------------------------------
  header u_slash_mod_,'u/mod',0 ; {{{2

; doc{
;
; u/mod ( -- ) ; XXX TODO -- stack
;
; }doc

  call pop_hl
  ld b,h
  ld c,l
  call pop_hl_de
  ld a,l
  sub c
  ld a,h
  sbc a,b
  jr c,l5dc3h
  ld hl,$FFFF
  ld de,$FFFF
  jp l5de3h
l5dc3h:
  ld a,$10
l5dc5h:
  add hl,hl
  rla
  ex de,hl
  add hl,hl
  jr nc,l5dcdh
  inc de
  and a
l5dcdh:
  ex de,hl
  rra
  push af
  jr nc,l5dd7h
  and l
  sbc hl,bc
  jp l5ddeh
l5dd7h:
  and a
  sbc hl,bc
  jr nc,l5ddeh
  add hl,bc
  dec de
l5ddeh:
  inc de
  pop af
  dec a
  jr nz,l5dc5h
l5de3h:
  ex de,hl
  jp push_de_hl

; --------------------------------------------------------------
  header less_number_sign_,'<#',0 ; {{{2

; doc{
;
; <# ( -- ) ; XXX TODO -- stack
;
; }doc

  call pad_
  call pop_hl
  ld (hlds_fvar),hl
  ret

; --------------------------------------------------------------
  header number_sign_greater_,'#>',0 ; {{{2

; doc{
;
; #> ( -- ) ; XXX TODO -- stack
;
; }doc

  call pop_hl_de
  ld hl,(hlds_fvar)
  call push_hl
  call pad_
  call over_
  jp minus_

; --------------------------------------------------------------
  header number_sign_,'#',0 ; {{{2

; doc{
;
; # ( -- ) ; XXX TODO -- stack
;
; }doc

  ; XXX TODO -- avoid fetching base every time `#s` calls `#`:
  ld hl,(base)
  call push_hl
  call sub_5fc2h
  call rot_
  ld hl,$0009
  call push_hl
  call over_
  call less_than_
  call zero_branch_
  dw branch_5e39
  ld hl,$0007
  call push_hl
  call plus_
branch_5e39:
  ld hl,$0030
  call push_hl
  call plus_
  jp hold_

sub_5fc2h:
  call r_from_
  ld hl,$0000
  call push_hl
  call to_r_
  call dup_
  call r_from_
  call u_slash_mod_
  call to_r_
  call swap_
  call r_from_
  call u_slash_mod_
  call to_r_
  ret

; --------------------------------------------------------------
  header number_sign_s_,'#s',0 ; {{{2

; doc{
;
; #s ( -- ) ; XXX TODO -- stack
;
; }doc

  call number_sign_
  call over_ ; XXX TODO -- over over -> 2dup
  call over_
  call or_
  call question_branch_
  dw number_sign_s_
  ret

; --------------------------------------------------------------
  header d_dot_,'d.',0 ; {{{2

; doc{
;
; d. ( d -- )
;
; }doc

  ; XXX FIXME -- 2020-05-27

  call less_number_sign_
  call number_sign_s_
  call number_sign_greater_
  call type_
  jp space_

; --------------------------------------------------------------
  header hold_,'hold',0 ; {{{2

; doc{
;
; hold ( c -- )
;
; }doc

  ld hl,(hlds_fvar)
  dec hl
  ld (hlds_fvar),hl
  call pop_hl
  ld a,l
  ld hl,(hlds_fvar)
  ld (hl),a
  ret

; --------------------------------------------------------------
  header sign_,'sign',0 ; {{{2

; doc{
;
; sign ( n d -- ) ; XXX TODO -- stack
;
; }doc

  ; sign ( n -- ) ; XXX TODO -- standard

  call rot_ ; XXX TODO -- this is not standard
  call zero_less_
  call zero_exit_
  call c_lit_
  db "-"
  call hold_
  ret

; --------------------------------------------------------------
  header zero_equals_,'0=',0 ; {{{2

; doc{
;
; 0= ( n -- f )
;
; See: `negate`, `invert`.
;
; }doc

  call pop_hl
  ld a,l
  or h
  jp z,false
  jp true

; --------------------------------------------------------------
  header zero_less_,'0<',0 ; {{{2

; doc{
;
; 0< ( n -- f )
;
; }doc

  call pop_hl
  bit 7,h
  jp z,false
  jp true

; --------------------------------------------------------------
  header forget_,'forget',0 ; {{{2

; doc{
;
; forget ( "name" -- )
;
; }doc

  call find_
  ex de,hl
  call pop_hl
  ld a,h
  or l
  check "undefined 4"
  jp z,not_found_error
  ld hl,(fence)
  sbc hl,de
  jp nc,invalid_forget_error
  ex de,hl
  dec hl
  ld b,(hl)
  dec hl
  ld c,(hl)
  ld (latest),bc
  ld (dp),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header error_,'error',0 ; {{{2

; doc{
;
; error ( -n -- )
;
; }doc

  call pop_hl
  jp error_hl

; --------------------------------------------------------------
  header paren_,'(',immediate ; {{{2

; doc{
;
; ( ( "text"<closing-paren> -- )
;
; }doc

  ld hl,(ip_fvar)
paren_.next:
  inc hl
  ld a,')'
  cp (hl)
  jr nz,paren_.next
  ld (ip_fvar),hl
  ret

; --------------------------------------------------------------
  header pick_,'pick',0 ; {{{2

; doc{
;
; pick ( x#u...x#1 x#0 u -- x#u...x#1 x#0 x#u )
;
; }doc

  call pop_hl
  ld a,h
  or l
  ret z
  ld e,l
  dec e
  rl e
  if data_stack_method = ix_dsm
    push ix
    pop hl
  else
    ld hl,(dsp)
  endif
  ld d,$00
  add hl,de
  ld c,(hl)
  inc hl
  ld b,(hl)
  ld h,b
  ld l,c
  jp push_hl

; --------------------------------------------------------------
  header roll_,'roll',0 ; {{{2

; doc{
;
; roll ( x#u x#u-1...x#0 u -- x#u-1...x#0 x#u )
;
; }doc

  call pop_hl
  ld a,h
  or l
  ret z
  ld b,l
  ld c,l
l5f79h:
  call pop_hl
  push hl
  djnz l5f79h
  pop de
  ld b,c
  dec b
l5f82h:
  pop hl
  call push_hl
  djnz l5f82h
  ld h,d
  ld l,e
  jp push_hl

; --------------------------------------------------------------
  header char_,'char',0 ; {{{2

; doc{
;
; char ( "c" -- )
;
; }doc

  ; XXX TODO use `word` instead

  ld hl,(ip_fvar)
char.skip_blanks:
  inc hl
  ld a,(hl)
  cp space_char
  jr z,char.skip_blanks
  cp cr_char
  jr nz,char.found
  ld l,0 ; result when not found
  jp char.return
char.found:
  ld b,a ; preserve the first char

char.skip_remaining:
  inc hl
  ld a,(hl)
  cp space_char
  jr z,char.restore
  cp cr_char
  jr nz,char.skip_remaining

char.restore:
  ld (ip_fvar),hl
  ld l,b ; get the preserved char
char.return:
  ld h,$00
  jp push_hl

; --------------------------------------------------------------
  header bracket_char_,'[char]',immediate ; {{{2

; doc{
;
; [char] ( "c" -- )
;
; }doc

  ld a,(state)
  and a ; compiling?
  jp z,compilation_only_error ; error if not compiling

  call char_
  call pop_hl
  ld b,h
  ld c,l
  ld de,lit_
  call compile_call_de
  ; hl = dp
  ld (hl),c
  inc hl
  ld (hl),b
  inc hl
  ld (dp),hl
  ret

; --------------------------------------------------------------
  header paper_,'paper',0 ; {{{2

; doc{
;
; paper ( n -- )
;
; }doc

  ld a,paper_char
  jp print_a_and_tos

; --------------------------------------------------------------
  header ink_,'ink',0 ; {{{2

; doc{
;
; ink ( n -- )
;
; }doc

  ld a,ink_char
  jp print_a_and_tos

; --------------------------------------------------------------
  header bright_,'bright',0 ; {{{2

; doc{
;
; bright ( f -- )
;
; }doc

  ld a,bright_char
  jp print_a_and_tos

; --------------------------------------------------------------
  header flash_,'flash',0 ; {{{2

; doc{
;
; flash ( f -- )
;
; }doc

  ld a,flash_char
print_a_and_tos:
  call print_a
  call pop_hl
  ld a,l
  jp print_a

; --------------------------------------------------------------
  header tab_,'tab',0 ; {{{2

; doc{
;
; tab ( -- )
;
; }doc

  ld a,tab_char
  jp print_a

; --------------------------------------------------------------
  header overprint_,'overprint',0 ; {{{2

; doc{
;
; overprint ( f -- )
;
; }doc

  ld a,over_char
  jp print_a_and_tos

; --------------------------------------------------------------
  header inverse_,'inverse',0 ; {{{2

; doc{
;
; inverse ( f -- )
;
; }doc

  ld a,inverse_char
  jp print_a_and_tos

; --------------------------------------------------------------
  header cat_,'cat',0 ; {{{2

; doc{
;
; cat ( n -- )
;
; }doc

  call pop_hl
  ld a,l
  ld (drive),a
  ld bc,basic_line_of_cat
  jp return.bc

; --------------------------------------------------------------
  header bsave_,'bsave',0 ; {{{2

; doc{
;
; bsave ( -- )
;
; }doc

  ; XXX TODO -- rewrite
  ret

; --------------------------------------------------------------
  header filename_store_,'filename!',0 ; {{{2

; doc{
;
; filename! ( ca len n -- )
;
; Copy a filename to a filename buffer.
;
; ca len = filename
; n      = filename buffer (0 or 1)
;
; }doc

  call pop_hl
  ld a,l
  ld de,filename.0
  and a ; filename buffer 0?
  jr z,filename_store.move
  ld de,filename.1
filename_store.move
  ; de = filename buffer address
  push de
  call pop_hl_de
  ld b,d
  ld c,e
  pop de
  ; hl = filename address
  ; de = filename buffer address
  ; bc = filename length
  ldir
  ret

; --------------------------------------------------------------
  header dload_,'dloaded',0 ; {{{2

; doc{
;
; dloaded ( a ca len -- )
;
; Load a code file into memory.
; ca len = filename
; a      = memory address
;
; }doc

  call pop_hl
  ld (file_address),hl
  ld bc,basic_line_of_load
  jp return.bc
  ret

; --------------------------------------------------------------
  header dsaved_,'dsaved',0 ; {{{2

; doc{
;
; dsaved ( a1 len1 ca2 len2 -- )
;
; a1 len1  = memory zone
; ca2 len2 = filename
;
; }doc

; XXX TODO -- rewrite
  ret

; --------------------------------------------------------------
  header push_hl_,'push-hl_',0 ; {{{2

; doc{
;
; push-hl_ ( -- x )
;
; }doc

  call do_constant
  dw push_hl

; --------------------------------------------------------------
  header pop_hl_,'pop-hl_',0 ; {{{2

; doc{
;
; pop-hl_ ( x -- )
;
; }doc

  call do_constant
  dw push_hl

; --------------------------------------------------------------
  header push_de_hl_,'push-de-hl_',0 ; {{{2

; doc{
;
; push-de-hl_ ( -- x1 x2 )
;
; }doc

  call do_constant
  dw push_de_hl

; --------------------------------------------------------------
  header pop_hl_de_,'pop-hl-de_',0 ; {{{2

; doc{
;
; pop-hl-de_ ( x1 x2 -- )
;
; }doc

  call do_constant
  dw pop_hl_de

; --------------------------------------------------------------
  header expand_,'expand',0 ; {{{2

; doc{
;
; expand ( -- )
; XXX TODO adapt?
;
; }doc

  ; XXX TODO -- write "save-system" or similar; rename?
  ld hl,(latest)
  ld (cold_latest),hl
  ld hl,(dp)
  ld (cold_dp),hl
  ld (fence),hl
  jp save_dictionary_pointers

; --------------------------------------------------------------
  header state_,'state',0 ; {{{2

; doc{
;
; state ( -- a )

call do_variable
state:
dw 0 ; compilation state flag (non-zero value when in compilation state)

; --------------------------------------------------------------
  header bounds_,'bounds',0 ; {{{2

; doc{
;
; bounds ( a n -- a' a )
;
; }doc

  call over_
  call plus_
  jp swap_

; --------------------------------------------------------------
  header left_bracket_,'[',immediate ; {{{2

; doc{
;
; [ ( -- ) "left-bracket"
;
; }doc

  ld hl,false
  ld (state),hl
  ret

; --------------------------------------------------------------
  header right_bracket_,']',0 ; {{{2

; doc{
;
; ] ( -- ) "right-bracket"
;
; }doc

  ld hl,true
  ld (state),hl
  ret

; --------------------------------------------------------------
  header unused_,'unused',0 ; {{{2

; doc{
;
; unused ( -- u )
;
; Return the amount of space remaining in the region addressed by `here`, in
; address units.
; XXX TODO adapt -- implement and use the heap pointer as top limit
;
; }doc

  ld de,(dp)
  ld hl,$0000
  sbc hl,de
  jp push_hl

; --------------------------------------------------------------
  header to_in_,'to_in',0 ; {{{2

; doc{
;
; >in ( -- +n )
;
; Return the address of a cell containing the offset in characters from
; the start of the input buffer to the start of the parse area.
;
; }doc

  ; XXX TODO -- not used yet
  ; XXX TODO -- convert `ip_fvar`, an absolute address, to `to_in`.
  ld hl,to_in
  jp push_hl
to_in:
  dw $0000

; --------------------------------------------------------------
  header depth_,'depth',0 ; {{{2

; doc{
;
; depth ( -- +n )
;
; Return the number of single-cell (16-bit in this case) values contained in
; the data stack before it was placed on the stack.
;
; }doc

  ld hl,(sp0)
  if data_stack_method = ix_dsm
    push ix
    pop de
  else
    ld de,(dsp)
  endif
  and a
  sbc hl,de
  srl h
  rr l
  jp push_hl

; --------------------------------------------------------------
  header question_error_,'?error',0 ; {{{2

; doc{
;
; ?error ( f n -- ) "question-error"
;
; If _f_ is non-zero, throw error code _n_
;
; Definition:

; ----
; : ?error ( f n -- ) swap if error else drop then ;
; ----

; }doc

  call pop_hl_de
  ex de,hl
  ld a,d
  or e
  jp nz,error_hl
  ret

; --------------------------------------------------------------
  header question_stack_,'?stack',0 ; {{{2

; doc{
;
; ?stack ( -- ) "question-stack"
;
; Throw an error if the data stack is out of bounds.
;
; }doc

  call sp_fetch_
  call lit_
  dw data_stack_limit
  call less_than_
  call pop_hl
  ld a,h
  or l
  jp nz,stack_overflow_error
  call sp0_
  call sp_fetch_
  call less_than_
  call pop_hl
  ld a,h
  or l
  jp nz,stack_underflow_error
  ret

; --------------------------------------------------------------
  header dot_s_,'.s',0 ; {{{2

; doc{
;
; .s ( -- )
;
; Copy and display the values currently on the data stack.
;
; }doc

  ret

;; XXX TODO -- easier in Forth
;;  call depth_
;;  call pop_hl ; XXX TODO -- pop_bc instead
;;  call dup_
;;  call bounds_
;;  ld b,h
;;  ld c,l
;;dot_s.next

current_latest: equ dot_s_nfa

end_of_code:

end start
